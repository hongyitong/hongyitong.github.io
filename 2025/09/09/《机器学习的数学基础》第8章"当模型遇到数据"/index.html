<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hongyitong.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="第8章 当模型遇到数据 在本书的第一部分，我们介绍了许多机器学习方法所依赖的数学基础。希望读者能够从第一部分学习到数学语言的基本形式，而我们接下来将利用这些形式来描述和讨论机器学习。本书的第二部分介绍了机器学习的四大支柱：  回归（第9章） 降维（第10章） 密度估计（第11章） 分类（第12章）  本书这一部分的主要目标是展示如何利用第一部分介绍的数学概念来设计机器学习算法，从而解决四大支柱范围">
<meta property="og:type" content="article">
<meta property="og:title" content="《机器学习的数学基础》第8章&quot;当模型遇到数据&quot;">
<meta property="og:url" content="http://hongyitong.github.io/2025/09/09/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E3%80%8B%E7%AC%AC8%E7%AB%A0%22%E5%BD%93%E6%A8%A1%E5%9E%8B%E9%81%87%E5%88%B0%E6%95%B0%E6%8D%AE%22/index.html">
<meta property="og:site_name" content="忆桐之家的博客">
<meta property="og:description" content="第8章 当模型遇到数据 在本书的第一部分，我们介绍了许多机器学习方法所依赖的数学基础。希望读者能够从第一部分学习到数学语言的基本形式，而我们接下来将利用这些形式来描述和讨论机器学习。本书的第二部分介绍了机器学习的四大支柱：  回归（第9章） 降维（第10章） 密度估计（第11章） 分类（第12章）  本书这一部分的主要目标是展示如何利用第一部分介绍的数学概念来设计机器学习算法，从而解决四大支柱范围">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80Part2/T8.1.png">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80Part2/T8.2.png">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80Part2/F8.1.png">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80Part2/F8.2.png">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80Part2/F8.3.png">
<meta property="og:image" content="http://hongyitong.github.io/2025/09/09/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E3%80%8B%E7%AC%AC8%E7%AB%A0%22%E5%BD%93%E6%A8%A1%E5%9E%8B%E9%81%87%E5%88%B0%E6%95%B0%E6%8D%AE%22/F8.4.png">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80Part2/F8.5.png">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80Part2/F8.6.png">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80Part2/F8.7.png">
<meta property="og:image" content="http://hongyitong.github.io/2025/09/09/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E3%80%8B%E7%AC%AC8%E7%AB%A0%22%E5%BD%93%E6%A8%A1%E5%9E%8B%E9%81%87%E5%88%B0%E6%95%B0%E6%8D%AE%22/F8.8.png">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80Part2/F8.9.png">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80Part2/F8.10.png">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80Part2/F8.11.png">
<meta property="og:image" content="http://hongyitong.github.io/Users/hongyuanjiao/Desktop/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E3%80%8BPart2/F8.12.png">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80Part2/F8.13.png">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80Part2/F8.14.png">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80Part2/F8.15.png">
<meta property="article:published_time" content="2025-09-08T16:00:00.000Z">
<meta property="article:modified_time" content="2025-09-09T03:39:54.492Z">
<meta property="article:author" content="Rayman.hung">
<meta property="article:tag" content="数学">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="统计">
<meta property="article:tag" content="深度学习">
<meta property="article:tag" content="机器学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hongyitong.github.io/img3/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80Part2/T8.1.png">


<link rel="canonical" href="http://hongyitong.github.io/2025/09/09/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E3%80%8B%E7%AC%AC8%E7%AB%A0%22%E5%BD%93%E6%A8%A1%E5%9E%8B%E9%81%87%E5%88%B0%E6%95%B0%E6%8D%AE%22/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://hongyitong.github.io/2025/09/09/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E3%80%8B%E7%AC%AC8%E7%AB%A0%22%E5%BD%93%E6%A8%A1%E5%9E%8B%E9%81%87%E5%88%B0%E6%95%B0%E6%8D%AE%22/","path":"2025/09/09/《机器学习的数学基础》第8章\"当模型遇到数据\"/","title":"《机器学习的数学基础》第8章\"当模型遇到数据\""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>《机器学习的数学基础》第8章"当模型遇到数据" | 忆桐之家的博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">忆桐之家的博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Rayman&Tony</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section">首页</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section">分类</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section">关于</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section">归档</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section">标签</a></li><li class="menu-item menu-item-commonweal"><a href="/404.html" rel="section">公益 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC8%E7%AB%A0-%E5%BD%93%E6%A8%A1%E5%9E%8B%E9%81%87%E5%88%B0%E6%95%B0%E6%8D%AE"><span class="nav-number">1.</span> <span class="nav-text">第8章 当模型遇到数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AD%A6%E4%B9%A0"><span class="nav-number">1.1.</span> <span class="nav-text">8.1 数据、模型与学习</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BD%9C%E4%B8%BA%E5%90%91%E9%87%8F"><span class="nav-number">1.1.1.</span> <span class="nav-text">8.1.1 数据作为向量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.2.</span> <span class="nav-text">8.1.2 模型作为函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BA%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E7%9A%84%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.3.</span> <span class="nav-text">8.1.3 作为概率分布的模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E5%B0%B1%E6%98%AF%E5%AF%BB%E6%89%BE%E5%8F%82%E6%95%B0"><span class="nav-number">1.1.4.</span> <span class="nav-text">8.1.4 学习就是寻找参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%8F%E9%AA%8C%E9%A3%8E%E9%99%A9%E6%9C%80%E5%B0%8F%E5%8C%96"><span class="nav-number">1.2.</span> <span class="nav-text">8.2 经验风险最小化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%87%E8%AE%BE%E5%87%BD%E6%95%B0%E7%B1%BB"><span class="nav-number">1.2.1.</span> <span class="nav-text">8.2.1 假设函数类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%AD%E7%BB%83%E7%9A%84%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.2.</span> <span class="nav-text">8.2.2 训练的损失函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E5%8C%96%E4%BB%A5%E5%87%8F%E5%B0%91%E8%BF%87%E6%8B%9F%E5%90%88"><span class="nav-number">1.2.3.</span> <span class="nav-text">8.2.3 正则化以减少过拟合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E8%AF%84%E4%BC%B0%E6%B3%9B%E5%8C%96%E6%80%A7%E8%83%BD"><span class="nav-number">1.2.4.</span> <span class="nav-text">8.2.4 交叉验证评估泛化性能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB"><span class="nav-number">1.2.5.</span> <span class="nav-text">8.2.5 延伸阅读</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1"><span class="nav-number">1.3.</span> <span class="nav-text">8.3 参数估计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1"><span class="nav-number">1.3.1.</span> <span class="nav-text">8.3.1 极大似然估计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E4%BC%B0%E8%AE%A1"><span class="nav-number">1.3.2.</span> <span class="nav-text">8.3.2 最大后验估计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E6%8B%9F%E5%90%88"><span class="nav-number">1.3.3.</span> <span class="nav-text">8.3.3 模型拟合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB-1"><span class="nav-number">1.3.4.</span> <span class="nav-text">8.3.4 延伸阅读</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E7%8E%87%E5%BB%BA%E6%A8%A1%E4%B8%8E%E6%8E%A8%E6%96%AD"><span class="nav-number">1.4.</span> <span class="nav-text">8.4 概率建模与推断</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E7%8E%87%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.4.1.</span> <span class="nav-text">8.4.1 概率模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%8E%A8%E6%96%AD"><span class="nav-number">1.4.2.</span> <span class="nav-text">8.4.2 贝叶斯推断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BD%9C%E5%8F%98%E9%87%8F%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.4.3.</span> <span class="nav-text">8.4.3 潜变量模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB-2"><span class="nav-number">1.4.4.</span> <span class="nav-text">8.4.4 延伸阅读</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.5.</span> <span class="nav-text">8.5 有向图模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E8%AF%AD%E4%B9%89"><span class="nav-number">1.5.1.</span> <span class="nav-text">8.5.1 图的语义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E7%8B%AC%E7%AB%8B%E4%B8%8E-d-%E5%88%86%E7%A6%BB"><span class="nav-number">1.5.2.</span> <span class="nav-text">8.5.2 条件独立与 d-分离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB-3"><span class="nav-number">1.5.3.</span> <span class="nav-text">8.5.3 延伸阅读</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9"><span class="nav-number">1.6.</span> <span class="nav-text">8.6 模型选择</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81"><span class="nav-number">1.6.1.</span> <span class="nav-text">8.6.1 嵌套交叉验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9"><span class="nav-number">1.6.2.</span> <span class="nav-text">8.6.2 贝叶斯模型选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%9B%A0%E5%AD%90%E7%94%A8%E4%BA%8E%E6%A8%A1%E5%9E%8B%E6%AF%94%E8%BE%83"><span class="nav-number">1.6.3.</span> <span class="nav-text">8.6.3 贝叶斯因子用于模型比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB-4"><span class="nav-number">1.6.4.</span> <span class="nav-text">8.6.4 延伸阅读</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Rayman.hung</p>
  <div class="site-description" itemprop="description">技术分享、读书心得、亲子时刻</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives">
          <span class="site-state-item-count">900</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags">
        <span class="site-state-item-count">1149</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hongyitong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hongyitong" rel="noopener" target="_blank">GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://blog.sina.com.cn/yitonghong" title="忆桐之家 → http:&#x2F;&#x2F;blog.sina.com.cn&#x2F;yitonghong" rel="noopener" target="_blank">忆桐之家</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://douban.com/people/2780741" title="豆瓣 → http:&#x2F;&#x2F;douban.com&#x2F;people&#x2F;2780741" rel="noopener" target="_blank">豆瓣</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://www.zhihu.com/people/rayman-36" title="知乎 → http:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;rayman-36" rel="noopener" target="_blank">知乎</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://www.liaoxuefeng.com/" title="廖雪峰的官方网站 → http:&#x2F;&#x2F;www.liaoxuefeng.com&#x2F;" rel="noopener" target="_blank">廖雪峰的官方网站</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://www.vaikan.com/" title="外刊IT评论 → http:&#x2F;&#x2F;www.vaikan.com&#x2F;" rel="noopener" target="_blank">外刊IT评论</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hongyitong.github.io/2025/09/09/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E3%80%8B%E7%AC%AC8%E7%AB%A0%22%E5%BD%93%E6%A8%A1%E5%9E%8B%E9%81%87%E5%88%B0%E6%95%B0%E6%8D%AE%22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rayman.hung">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="忆桐之家的博客">
      <meta itemprop="description" content="技术分享、读书心得、亲子时刻">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="《机器学习的数学基础》第8章"当模型遇到数据" | 忆桐之家的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《机器学习的数学基础》第8章"当模型遇到数据"
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-09-09 00:00:00 / 修改时间：11:39:54" itemprop="dateCreated datePublished" datetime="2025-09-09T00:00:00+08:00">2025-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BB%E4%B9%A6%E5%BF%83%E5%BE%97/" itemprop="url" rel="index"><span itemprop="name">读书心得</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="第8章-当模型遇到数据">第8章 当模型遇到数据</h2>
<p>在本书的第一部分，我们介绍了许多机器学习方法所依赖的数学基础。希望读者能够从第一部分学习到数学语言的基本形式，而我们接下来将利用这些形式来描述和讨论机器学习。本书的第二部分介绍了机器学习的四大支柱：</p>
<ul>
<li>回归（第9章）</li>
<li>降维（第10章）</li>
<li>密度估计（第11章）</li>
<li>分类（第12章）</li>
</ul>
<p>本书这一部分的主要目标是展示如何利用第一部分介绍的数学概念来设计机器学习算法，从而解决四大支柱范围内的任务。我们无意介绍高级的机器学习概念，而是希望提供一套实用的方法，使读者能够运用第一部分所学的知识。同时，这部分内容也为已经熟悉数学的读者提供了进入更广泛机器学习文献的入口。</p>
<span id="more"></span>
<h3 id="数据模型与学习">8.1 数据、模型与学习</h3>
<p>在这里，我们有必要停下来思考一下：机器学习算法究竟是为了解决什么问题。正如在第
1
章中所讨论的，一个机器学习系统主要由三个部分组成：<strong>数据</strong>、<strong>模型</strong>和<strong>学习</strong>。机器学习的核心问题是：<strong>“什么才是好的模型？”</strong></p>
<p>“模型”这个词有许多微妙的含义，我们将在本章中多次回顾它。而“好”的定义也并非显而易见。机器学习的一个基本指导原则是：<strong>好的模型应当在未见过的数据上也能表现良好</strong>。这要求我们定义一些性能度量标准，比如准确率或与真实值的距离，并找到在这些标准下表现良好的方法。</p>
<p>本章将介绍一些必要的数学与统计语言，这些语言通常用于讨论机器学习模型。通过这些内容，我们将简要勾勒如何训练模型的最佳实践，从而使得得到的预测器能够在尚未见过的数据上依然有效。</p>
<p>正如在第 1
章中提到的，“机器学习算法”这一表述有两层含义：<strong>训练</strong>与<strong>预测</strong>。在本章中，我们将描述这两个概念，以及<strong>在不同模型之间进行选择</strong>的思想。我们将在
<strong>8.2 节</strong>介绍<strong>经验风险最小化</strong>框架，在
<strong>8.3 节</strong>介绍<strong>极大似然原理</strong>，在 <strong>8.4
节</strong>介绍<strong>概率模型</strong>。在 <strong>8.5
节</strong>中，我们将简要概述一种用于指定概率模型的图形化语言，并在
<strong>8.6 节</strong>中讨论<strong>模型选择</strong>。</p>
<p>本节的剩余部分将进一步展开机器学习的三个核心组成部分：<strong>数据</strong>、<strong>模型</strong>和<strong>学习</strong>。</p>
<h4 id="数据作为向量">8.1.1 数据作为向量</h4>
<p>我们假设数据可以被计算机读取，并且能够以数值格式恰当地表示。数据被假设为表格形式（图
8.1），其中我们认为表格的每一行代表一个特定的实例或样本，而每一列对应一个特定的特征。</p>
<p>近年来，机器学习已经应用于许多并非显然以数值表格形式存在的数据，例如基因序列、网页的文本和图像内容，以及社交媒体图谱。我们在此不讨论<strong>如何识别出良好特征这一重要而具有挑战性的方面。这些方面中的许多依赖于领域专业知识并需要精心设计，而近年来它们被纳入了数据科学的范畴（</strong>Stray,
2016; Adhikari 和 DeNero, 2018）。</p>
<p>即使我们已经拥有表格格式的数据，仍然需要做出一些选择以获得数值表示。例如，在表
8.1 中，性别这一列（一个分类变量）可以被转换为数字，其中 0 表示“男性”，1
表示“女性”。另一种方法是将性别表示为 −1 和 +1（如表 8.2
所示）。此外，在构建表示时，利用领域知识往往十分重要，例如知道大学学位是从学士到硕士再到博士逐级进展，或者意识到邮编不仅仅是字符的组合，而是实际编码了伦敦的某个区域。在表
8.2 中，我们将表 8.1
的数据转换为数值格式，每个邮编被表示为两个数字：一个纬度和一个经度。</p>
<p><img src="/img3/机器学习的数学基础Part2/T8.1.png" alt="T8.1" style="zoom:50%;" /></p>
<p><img src="/img3/机器学习的数学基础Part2/T8.2.png" alt="T8.2" style="zoom:50%;" /></p>
<p>即便是那些可以直接输入机器学习算法的数值数据，也应当仔细考虑其单位、缩放方式和约束条件。在没有额外信息的情况下，应当将数据集的所有列进行平移和缩放，使其经验均值为
0，经验方差为
1。为了本书的讨论，我们假设领域专家已经适当地完成了数据转换，即每个输入
<span class="math inline">\(x_n\)</span> 是一个 <span
class="math inline">\(D\)</span>
维实数向量，被称为特征、属性或协变量。我们认为数据集的形式如表 8.2
所示。</p>
<p>请注意，在新的数值表示中，我们去掉了表 8.1
中的“姓名”这一列。这么做有两个主要原因：(1)
我们不认为标识符（姓名）对机器学习任务有帮助；(2)
我们可能希望对数据进行匿名化，以帮助保护员工的隐私。</p>
<p>在本书的这一部分，我们用 <span
class="math inline">\(N\)</span>表示数据集中样本的数量，并用小写字母$ n
= 1, …, N$
来索引这些样本。我们假设给定了一组数值型数据，表示为一个向量数组（见表
8.2）。每一行代表一个个体 <span
class="math inline">\(x_n\)</span>，在机器学习中通常称为样本或数据点。下标
<span class="math inline">\(n\)</span>表示这是数据集中第<span
class="math inline">\(n\)</span>个样本，总共有<span
class="math inline">\(N\)</span>个样本。每一列代表该样本的一个特征，我们将特征索引为
<span class="math inline">\(d = 1, …,
D\)</span>。回忆一下，数据是用向量表示的，这意味着每个样本（每个数据点）是一个
<span
class="math inline">\(D\)</span>维向量。<strong>这种表格的排列方式来源于数据库领域，但在某些机器学习算法（例如第
10 章中的方法）中，将样本表示为列向量会更加方便。</strong></p>
<p>让我们考虑一个根据年龄预测年薪的问题，基于表 8.2
中的数据。这就是一个监督学习问题，其中每个样本 <span
class="math inline">\(xₙ\)</span>（年龄）都有一个对应的标签 <span
class="math inline">\(yₙ\)</span>（薪水）。标签 <span
class="math inline">\(yₙ\)</span>
还有其他叫法，包括<strong>目标值（target）</strong>、<strong>响应变量（response
variable）和注释（annotation）</strong>。一个数据集可以写成一组样本-标签对的集合：
<span class="math inline">\({(x_1, y_2), …, (x_n, y_n), …, (x_N,
y_N)}\)</span>。样本表$ {x₁, …, x_N} $通常会拼接在一起，写作 <span
class="math inline">\(X ∈ ℝ^{N*D}\)</span>。图 8.1 展示了由表 8.2
最右两列构成的数据集，其中 <span class="math inline">\(x\)</span> =
年龄，<span class="math inline">\(y\)</span> = 薪水。</p>
<figure>
<img src="/img3/机器学习的数学基础Part2/F8.1.png" alt="F8.1" />
<figcaption aria-hidden="true">F8.1</figcaption>
</figure>
<p>我们使用本书第一部分介绍的概念来形式化机器学习问题，例如上一段中提到的那种问题。
将数据表示为向量 <span class="math inline">\(x_n\)</span>
使我们能够使用线性代数中的概念（在第 2
章介绍）。在许多机器学习算法中，我们还需要能够比较两个向量。正如我们将在第
9 章和第 12
章看到的那样，计算两个样本之间的相似性或距离，可以帮助我们形式化这样一种直觉：具有相似特征的样本应当有相似的标签。比较两个向量需要我们构建一个几何结构（在第
3 章解释），并使我们能够使用第 7
章中的技术来优化由此产生的学习问题。</p>
<p><strong>既然我们已经有了数据的向量表示，那么我们就可以对数据进行操作，以寻找潜在的更优表示。我们将通过两种方式来讨论如何找到好的表示：一种是寻找原始特征向量的低维近似，另一种是利用原始特征向量的非线性高维组合。</strong></p>
<p>在第10章中，我们将看到通过寻找<strong>主成分来得到原始数据空间的低维近似的例子</strong>。寻找主成分与第4章介绍的特征值分解和奇异值分解的概念密切相关。</p>
<p>对于高维表示，我们将看到一个显式的特征映射 φ(·)，它允许我们将输入向量
<span class="math inline">\(x_n\)</span> 表示为一个高维表示 <span
class="math inline">\(\phi(x_n)\)</span>。高维表示的主要动机在于：我们可以<strong>将原始特征的非线性组合构造成新的特征，而这反过来可能会使学习问题变得更容易</strong>。我们将在第9.2节中讨论特征映射，并在第12.4节中展示<strong>这种特征映射是如何引出核函数的</strong>。</p>
<p>近年来，深度学习方法（Goodfellow
等，2016）在利用数据本身来学习新的、更优的特征方面展现出了巨大潜力，并在计算机视觉、语音识别和自然语言处理等领域取得了非常成功的应用。本书的这一部分不会涉及神经网络，但读者可以参考第5.6节，其中包含了关于反向传播的数学描述，这是训练神经网络的关键概念。</p>
<h4 id="模型作为函数">8.1.2 模型作为函数</h4>
<p>一旦我们将数据转换为合适的向量表示，就可以着手构建一个预测函数（predictive
function）（称为预测器）。</p>
<p>在第 1
章中，我们还没有精确描述“模型”的语言。利用本书前半部分介绍的概念，我们现在可以引入“模型”的含义。本书主要介绍两种方法：<strong>预测器作为函数</strong>，以及<strong>预测器作为概率模型</strong>。我们将在这里描述前者，而在下一小节介绍后者。</p>
<p>预测器是一个函数：当输入一个具体的样本（在我们的情形下，是一个特征向量）时，它会产生一个输出。现在先假设输出是一个单一数值，即实数标量输出。这个关系可以写成：
<span class="math display">\[
f : \mathbb{R}^D \to \mathbb{R}, \tag{8.1}
\]</span> 其中输入向量 <span class="math inline">\(x\)</span> 是 <span
class="math inline">\(D\)</span> 维的（即有 <span
class="math inline">\(D\)</span> 个特征），而函数 <span
class="math inline">\(f\)</span> 作用于它（记作 <span
class="math inline">\(f(x)\)</span>）后返回一个实数。图 8.2
展示了一个可能的函数，它可以用来计算输入值 <span
class="math inline">\(x\)</span> 的预测结果。</p>
<p><img src="/img3/机器学习的数学基础Part2/F8.2.png" alt="F8.2" style="zoom:50%;" /></p>
<p>在本书中，我们不会考虑所有函数的一般情况，因为那需要用到泛函分析。相反，我们只考虑<strong>线性函数</strong>这一特殊情况：
<span class="math display">\[
f(x) = \theta^\top x + \theta_0 \quad (8.2)
\]</span> 其中 <span class="math inline">\(\theta\)</span> 和 <span
class="math inline">\(\theta_0\)</span> 是未知的。这个限制意味着，仅凭第
2 章和第 3
章的内容，就足以精确地表述“预测器”的概念（针对非概率的视角，相对于接下来要介绍的概率视角）。<strong>线性函数在“可解决问题的广泛性”和“所需数学背景的复杂程度”之间，达成了一个很好的平衡。</strong></p>
<h4 id="作为概率分布的模型">8.1.3 作为概率分布的模型</h4>
<p><strong>我们常常将数据看作是某种真实潜在效应的带噪声观测，并希望通过机器学习来从噪声中识别出信号。这就需要一种能够量化噪声影响的语言。我们也常常希望预测器能够表达某种不确定性</strong>，例如，能够量化在某个特定测试数据点上的预测值的置信程度。正如我们在第
6 章中看到的，概率论提供了一种量化不确定性的语言。图 8.3
展示了函数预测不确定性如何可以用高斯分布来表示。</p>
<p>与其把预测器看作是单一函数，我们可以把预测器视为<strong>概率模型</strong>，即描述可能函数分布的模型。在本书中，我们将范围限制在具有有限维参数的分布这一特殊情形，这样就可以在不需要随机过程和随机测度的情况下描述概率模型。在这种特殊情况下，我们可以把概率模型看作是<strong>多元概率分布</strong>，而这已经能够涵盖丰富的模型类别。</p>
<p>我们将在 <strong>8.4 节</strong> 中介绍如何利用概率论（第 6
章的内容）来定义机器学习模型，并在 <strong>8.5 节</strong>
中介绍一种图形化语言，以紧凑的方式描述概率模型。</p>
<p><img src="/img3/机器学习的数学基础Part2/F8.3.png" alt="F8.3" style="zoom:50%;" /></p>
<h4 id="学习就是寻找参数"><strong>8.1.4 学习就是寻找参数</strong></h4>
<p>学习的目标是找到一个模型及其对应的参数，使得由此得到的预测器能够在未见过的数据上表现良好。</p>
<p>在讨论机器学习算法时，从概念上可以区分出三个不同的算法阶段：</p>
<ol type="1">
<li><strong>预测或推断</strong></li>
<li><strong>训练或参数估计</strong></li>
<li><strong>超参数调优或模型选择</strong></li>
</ol>
<p>预测阶段是指在已经训练好的预测器上使用以前未见过的测试数据。换句话说，此时参数和模型的选择已经固定，预测器被应用到代表新输入数据点的新向量上。正如第
1
章和前一小节所述，在本书中我们将考虑机器学习的两种学派，对应于预测器是一个函数还是一个概率模型。<strong>当我们拥有一个概率模型时（将在第
8.4 节进一步讨论），预测阶段被称为推断（inference）。</strong></p>
<p><strong>备注：</strong>
不幸的是，对于这些不同的算法阶段，<strong>并没有统一的命名。“推断（inference）”一词有时也被用来指概率模型的参数估计</strong>（个人注：Bayesian
Inference
贝叶斯推断），而在更少的情况下，它也可能被用来指非概率模型的预测。</p>
<p><strong>训练或参数估计阶段</strong>是我们根据训练数据来调整预测模型的过程。我们希望在给定训练数据的情况下找到好的预测器，而主要有两种方法来实现这一目标：</p>
<ol type="1">
<li>基于某种质量度量找到最优的预测器（有时称为<strong>点估计</strong>），</li>
<li>使用<strong>贝叶斯推断</strong>。</li>
</ol>
<p>点估计可以应用于两类预测器，但贝叶斯推断需要概率模型。</p>
<p>对于非概率模型，我们遵循<strong>经验风险最小化</strong>(empirical
risk minimization)（将在第 8.2
节介绍）。经验风险最小化直接给出了一个用于寻找良好参数的优化问题。对于统计模型，我们使用<strong>极大似然原则</strong>来找到一组合适的参数（见第
8.3 节）。我们还可以利用概率模型来刻画参数的不确定性，这将在第 8.4
节更详细地讨论。</p>
<p>我们使用数值方法来寻找“拟合”数据的良好参数，大多数训练方法都可以看作是<strong>爬山法</strong>（hill-climbing）的思路，即寻找某个目标函数的最大值，例如似然函数的最大值。</p>
<p>在应用爬山法时，我们会用到第 5
章中描述的<strong>梯度</strong>，并结合第 7
章中的数值优化方法来实现。</p>
<blockquote>
<p>在优化领域的惯例是<strong>最小化目标函数</strong>。因此，在机器学习目标函数中经常会多出一个负号。</p>
</blockquote>
<p>正如在第 1
章提到的，我们的目标是基于数据学习一个模型，使其在未来数据上也能有良好表现。仅仅在训练数据上拟合得好是不够的，预测器还需要在未见过的数据上表现良好。为了模拟预测器在未来未知数据上的行为，我们使用交叉验证（第
8.2.4
节）。正如我们将在本章看到的，为了实现这一目标，我们需要在“很好地拟合训练数据”和“找到对现象的简单解释”之间取得平衡。这种权衡可以通过正则化（第
8.2.3 节）或引入先验（第 8.3.2
节）来实现。在哲学中，这既不被视为归纳（induction），也不被视为演绎（deduction），而是被称为溯因（abduction）。根据《斯坦福哲学百科全书》的解释，溯因是“推理出最佳解释的过程”（Douven,
2017）。</p>
<p>我们经常需要对预测器的结构做出高层次的建模决策，例如使用多少个成分，或者考虑哪一类概率分布。成分数的选择就是超参数（hyperparameter）的一个例子，而这种选择会显著影响模型的性能。在不同模型之间进行选择的问题被称为模型选择（model
selection），我们将在第 8.6
节中描述。对于非概率模型，模型选择通常使用嵌套交叉验证来完成，这将在第
8.6.1 节中讲解。我们也使用模型选择来决定模型的超参数。</p>
<p><strong>备注</strong>：<strong>参数（parameter）与超参数（hyperparameter）的区别在某种程度上是人为的，主要取决于它们是可以通过数值优化得到，还是需要用搜索方法确定。</strong>另一种区分方式是：将参数理解为概率模型的显式参数，而将超参数（更高层次的参数）理解为用来控制这些显式参数分布的参数。</p>
<p>在接下来的章节中，我们将讨论三种机器学习方法：经验风险最小化（第 8.2
节）、最大似然原理（第 8.3 节）以及概率建模（第 8.4 节）。</p>
<h3 id="经验风险最小化">8.2 经验风险最小化</h3>
<p>Empirical Risk Minimization</p>
<p>在掌握了所有数学工具之后，我们现在可以介绍“学习”到底意味着什么。机器学习中的“学习”部分，归根结底就是基于训练数据来估计参数。</p>
<p>在本节中，我们考虑预测器是一个函数的情况，而在 8.3 节
中再讨论概率模型的情况。我们将描述 经验风险最小化
的思想，这一思想最初是由支持向量机（将在 第 12 章
介绍）的提出而普及的。然而，它的一般原理具有广泛的适用性，使我们能够在不显式构造概率模型的情况下，提出“什么是学习”这个问题。</p>
<p>这里有四个主要的设计选择，我们会在接下来的小节中详细讨论：</p>
<p><strong>8.2.1</strong> 我们允许预测器取的函数集合是什么？</p>
<p><strong>8.2.2</strong> 我们如何衡量预测器在训练数据上的表现？</p>
<p><strong>8.2.3</strong>
我们如何仅凭训练数据来构造一个在未见过的测试数据上也表现良好的预测器？</p>
<p><strong>8.2.4</strong> 我们如何在模型空间中进行搜索？</p>
<h4 id="假设函数类">8.2.1 假设函数类</h4>
<p>Hypothesis Class of Functions</p>
<p>假设我们有 <span class="math inline">\(N\)</span> 个样本 <span
class="math inline">\(x_n \in \mathbb{R}^D\)</span>，以及对应的标量标签
<span class="math inline">\(y_n \in \mathbb{R}\)</span>。我们考虑的是
<strong>监督学习（supervised learning）</strong>
的设定，即我们得到样本对 <span class="math display">\[
(x_1, y_1), \ldots, (x_N, y_N).
\]</span> 在给定这些数据的情况下，我们希望去估计一个预测器 <span
class="math display">\[
f(\cdot, \theta): \mathbb{R}^D \to \mathbb{R},
\]</span> 它由参数 <span class="math inline">\(\theta\)</span>
控制。我们希望能够找到一个较好的参数 <span
class="math inline">\(\theta^*\)</span>，使得预测器能够很好地拟合数据，即：
<span class="math display">\[
f(x_n, \theta^*) \approx y_n, \quad n = 1, \ldots, N. \tag{8.3}
\]</span> 在本节中，我们使用符号 <span class="math display">\[
\hat{y}_n = f(x_n, \theta^*)
\]</span> 来表示预测器的输出。</p>
<p><strong>备注：</strong> 为了方便表述，我们将在有标签的
<strong>监督学习</strong>
框架下描述经验风险最小化。这简化了假设函数类和损失函数的定义。在机器学习中，一个常见的做法是选择一个参数化的函数类，例如仿射函数。</p>
<p><strong>例 8.1</strong>
我们引入普通最小二乘回归问题来说明经验风险最小化。关于回归的更全面讨论将在第
9 章中给出。当标签 <span class="math inline">\(y_n\)</span>
是实数时，一类常见的预测函数集合是仿射函数。为了更紧凑地表示仿射函数，我们通过在特征向量
<span class="math inline">\(x_n\)</span> 中拼接一个附加的单位特征 <span
class="math inline">\(x^{(0)} = 1\)</span>，得到 <span
class="math display">\[
x_n = [1, x_n^{(1)}, x_n^{(2)}, \ldots, x_n^{(D)}]^\top .
\]</span> 相应地，参数向量为 <span class="math display">\[
\theta = [\theta_0, \theta_1, \theta_2, \ldots, \theta_D]^\top ,
\]</span> 这样我们就能把预测器写成一个线性函数： <span
class="math display">\[
f(x_n, \theta) = \theta^\top x_n . \tag{8.4}
\]</span> 这个线性预测器等价于仿射模型： <span class="math display">\[
f(x_n, \theta) = \theta_0 + \sum_{d=1}^D \theta_d x_n^{(d)} . \tag{8.5}
\]</span> 预测器把一个单个样本的特征向量 <span
class="math inline">\(x_n\)</span> 作为输入，并输出一个实值，即 <span
class="math display">\[
f : \mathbb{R}^{D+1} \to \mathbb{R}.
\]</span>
本章前面的图像中，预测器是一条直线，这意味着我们假设的是一个仿射函数。</p>
<p>除了线性函数，我们可能希望考虑非线性函数作为预测器。近年来神经网络的进展使得更复杂的非线性函数类的高效计算成为可能。</p>
<p>给定一个函数类，我们希望寻找一个好的预测器。接下来我们转向经验风险最小化的第二个要素：如何衡量预测器对训练数据的拟合程度。</p>
<h4 id="训练的损失函数"><strong>8.2.2 训练的损失函数</strong></h4>
<p>考虑某个样本的标签 <span class="math inline">\(y_n\)</span>
以及基于特征向量 <span class="math inline">\(x_n\)</span> 做出的预测
<span
class="math inline">\(\hat{y}_n\)</span>。为了定义“拟合数据良好”的含义，我们需要指定一个损失函数
<span class="math inline">\(\ell(y_n,
\hat{y}_n)\)</span>，它以真实标签和预测值作为输入，并输出一个非负数（称为损失），表示我们在这个预测上犯了多少错误。我们寻找一个好的参数向量
<span class="math inline">\(\theta^*\)</span> 的目标是最小化 <span
class="math inline">\(N\)</span> 个训练样本上的平均损失。</p>
<p>在机器学习中常作的一个假设是，训练样本 <span
class="math inline">\((x_1, y_1), \dots, (x_N, y_N)\)</span>
是独立同分布的。<strong>这里的“独立”（参见第 6.4.5
节）意味着任意两个数据点 <span class="math inline">\((x_i, y_i)\)</span>
和 <span class="math inline">\((x_j, y_j)\)</span>
在统计上互不依赖，这也意味着经验均值可以很好地估计总体均值（参见第 6.4.1
节）</strong>。这一点表明，我们可以使用训练数据上的经验均值来衡量损失。</p>
<p>对于给定的训练集 <span class="math inline">\(\{(x_1, y_1), \dots,
(x_N, y_N)\}\)</span>，我们引入矩阵表示法：样本矩阵 <span
class="math display">\[
X := [x_1, \dots, x_N]^\top \in \mathbb{R}^{N \times D}
\]</span> 以及标签向量 <span class="math display">\[
y := [y_1, \dots, y_N]^\top \in \mathbb{R}^N .
\]</span> 使用这种矩阵表示法，平均损失定义为： <span
class="math display">\[
R_{\text{emp}}(f, X, y) = \frac{1}{N} \sum_{n=1}^{N} \ell(y_n,
\hat{y}_n), \quad \text{其中 } \hat{y}_n = f(x_n, \theta). \tag{8.6}
\]</span> <strong>式 (8.6) 称为经验风险</strong>(empirical
risk)，它依赖三个参数：预测器 <span class="math inline">\(f\)</span>
和数据 <span class="math inline">\(X,
y\)</span>。这种基于经验风险的学习策略称为
<strong>经验风险最小化</strong>（Empirical Risk Minimization）。</p>
<blockquote>
<p>个人注：<strong>经验风险</strong>(empirical risk)
和下文的<strong>期望风险</strong>（expected risk）对应！</p>
</blockquote>
<p><strong>例 8.2（最小二乘损失）</strong></p>
<p>延续最小二乘回归的例子，我们指定在训练过程中测量预测误差的代价使用平方损失函数：
<span class="math display">\[
\ell(y_n, \hat{y}_n) = (y_n - \hat{y}_n)^2.
\]</span> 我们的目标是最小化经验风险 (8.6)，也就是对数据上损失的平均值：
<span class="math display">\[
\min_{\theta \in \mathbb{R}^D} \frac{1}{N} \sum_{n=1}^{N} (y_n - f(x_n,
\theta))^2, \tag{8.7}
\]</span> 其中我们将预测器代入 <span class="math inline">\(\hat{y}_n =
f(x_n, \theta)\)</span>。</p>
<p>使用线性预测器的选择 <span class="math inline">\(f(x_n, \theta) =
\theta^\top x_n\)</span>，我们得到优化问题： <span
class="math display">\[
\min_{\theta \in \mathbb{R}^D} \frac{1}{N} \sum_{n=1}^{N} (y_n -
\theta^\top x_n)^2. \tag{8.8}
\]</span> 这个方程也可以等价地用矩阵形式表示为： <span
class="math display">\[
\min_{\theta \in \mathbb{R}^D} \frac{1}{N} \|y - X\theta\|^2. \tag{8.9}
\]</span> 这就是所谓的 <strong>最小二乘问题</strong>( least-squares
problem.)。通过解正态方程（normal
equations），可以得到这个问题的解析闭式解，这将在第 9.2 节讨论。</p>
<p>我们并不关心一个仅在训练数据上表现良好的预测器。相反，我们希望得到一个在未见过的测试数据上也能表现良好（即风险低）的预测器。更正式地说，我们希望找到一个预测器
<span
class="math inline">\(f\)</span>（参数已固定），使其<strong>期望风险</strong>（expected
risk）最小： <span class="math display">\[
R_{\text{true}}(f) = \mathbb{E}_{x,y}[\ell(y, f(x))], \tag{8.10}
\]</span> 其中 <span class="math inline">\(y\)</span> 是标签，<span
class="math inline">\(f(x)\)</span> 是基于样本 <span
class="math inline">\(x\)</span> 的预测。符号 <span
class="math inline">\(R_{\text{true}}(f)\)</span>
表示如果我们拥有无限量的数据，这就是<strong>真实风险</strong>。期望是对所有可能的数据和标签（无限集合）进行的。</p>
<p>从我们希望最小化期望风险的角度出发，会产生两个实际问题，我们将在接下来的两个小节中讨论：</p>
<ol type="1">
<li>我们应该如何调整训练过程以实现良好的泛化能力？</li>
<li>我们如何从有限数据中估计期望风险？</li>
</ol>
<p><strong>备注</strong>：许多机器学习任务会指定一个<strong>相关的性能指标，例如预测的准确率或均方根误差（RMSE）</strong>。性能指标可能更复杂，也可能对成本敏感，并捕捉特定应用的细节。<strong>原则上，为经验风险最小化设计的损失函数应直接对应于机器学习任务指定的性能指标</strong>。但在实际操作中，损失函数的设计与性能指标往往存在不匹配。这可能是由于实现方便性或优化效率等问题造成的。</p>
<h4 id="正则化以减少过拟合">8.2.3 正则化以减少过拟合</h4>
<p>本节介绍了对经验风险最小化（Empirical Risk Minimization,
ERM）的一个补充，使其能够更好地泛化（即近似最小化期望风险）。回想一下，训练机器学习预测器的目标是让其在未见过的数据上表现良好，即预测器具有良好的<strong>泛化能力</strong>。我们通过从整个数据集中保留一部分数据来模拟这些未见过的数据，这部分数据称为<strong>测试集</strong>。</p>
<p>如果给定了一个足够丰富的函数类来表示预测器 <span
class="math inline">\(f\)</span>，我们基本上可以“记住”训练数据，从而得到零经验风险。虽然这在最小化训练数据上的损失（以及风险）方面非常有效，但我们不能期望预测器在未见过的数据上也有良好表现。在实际操作中，我们只有有限的数据集，因此需要将数据分为训练集和测试集。<strong>训练集用于拟合模型，而测试集（在训练期间算法未见过）用于评估泛化性能。重要的是，用户在观察测试集后不要再回到新一轮训练中。</strong>我们用下标
<code>train</code> 和 <code>test</code> 分别表示训练集和测试集。在第
8.2.4 节中，我们将再次讨论使用有限数据集来评估期望风险的思想。</p>
<p>实际上，经验风险最小化可能导致<strong>过拟合</strong>，即预测器过于贴合训练数据，而无法很好地泛化到新数据（Mitchell,
1997）。当训练数据量少而假设空间复杂时，这种现象尤其常见：训练集的平均损失很小，但测试集的平均损失很大。对于固定参数的特定预测器
<span class="math inline">\(f\)</span>，当训练数据的经验风险 <span
class="math inline">\(R_{\text{emp}}(f, X_{\text{train}},
y_{\text{train}})\)</span> 低估了期望风险 <span
class="math inline">\(R_{\text{true}}(f)\)</span>
时，就会发生过拟合。如果我们<strong>使用测试集上的经验风险 <span
class="math inline">\(R_{\text{emp}}(f, X_{\text{test}},
y_{\text{test}})\)</span>
来估计期望风险</strong>，并发现测试风险远大于训练风险，这就是过拟合的一个信号。我们将在第
8.3.3 节中再次讨论过拟合的概念。</p>
<p>因此，我们需要通过引入一个<strong>惩罚项</strong>来调整经验风险最小化的搜索方向，使优化器更难返回过于灵活的预测器。在机器学习中，这个惩罚项称为<strong>正则化（regularization）</strong>。<strong>正则化是一种在精确求解经验风险最小化和控制解的大小或复杂度之间进行折衷的方法。</strong></p>
<p><strong>示例 8.3（正则化最小二乘法）</strong></p>
<p>正则化是一种方法，用于抑制优化问题中复杂或极端的解。最简单的正则化策略是将前一个例子中的最小二乘问题
<span class="math display">\[
\min_{\theta} \frac{1}{N} \|y - X\theta\|^2 \tag{8.11}
\]</span> 替换为<strong>正则化</strong>问题，通过添加一个仅涉及 <span
class="math inline">\(\theta\)</span> 的惩罚项： <span
class="math display">\[
\min_{\theta} \frac{1}{N} \|y - X\theta\|^2 + \lambda \|\theta\|^2
\tag{8.12}
\]</span> 附加的项 <span class="math inline">\(\|\theta\|^2\)</span>
称为<strong>正则化项</strong>（regularizer），参数 <span
class="math inline">\(\lambda\)</span>
称为<strong>正则化参数</strong>。正则化参数用于在最小化训练集上的损失和控制参数
<span class="math inline">\(\theta\)</span>
的大小之间进行折衷。如果出现过拟合，参数值的大小通常会变得相对较大（Bishop,
2006）。</p>
<p><strong>正则化项有时也称为惩罚项，它使向量 <span
class="math inline">\(\theta\)</span>
更接近原点。正则化的思想在概率模型中也出现，表现为参数的先验概率。</strong>回想第
6.6
节，为了使后验分布与先验分布具有相同的形式，先验和似然函数需要是共轭的。我们将在第
8.3.2 节再次讨论这一思想。在第 12
章中，我们将看到正则化项的思想与大间隔（large
margin）的思想是等价的。</p>
<h4 id="交叉验证评估泛化性能">8.2.4 交叉验证评估泛化性能</h4>
<p>在上一节中，我们提到通过在测试数据上应用预测器来估计泛化误差。这些数据有时也称为验证集。验证集是从可用训练数据中留出的一部分。使用这种方法的一个实际问题是数据量有限，而理想情况下我们希望使用尽可能多的数据来训练模型。这就要求我们将验证集
<span class="math inline">\(\mathcal V\)</span>
保持较小，但这样会导致对预测性能的估计存在较大噪声（高方差）。解决这一矛盾目标（大训练集、大验证集）的一种方法是使用交叉验证。</p>
<p><span class="math inline">\(K\)</span> 折交叉验证有效地将数据集划分为
<span class="math inline">\(K\)</span>
个子块，每次使用其中最后一块作为验证集 <span
class="math inline">\(\mathcal
V\)</span>（类似于之前描述的思路）。交叉验证会遍历所有可能的子块分配组合，将某些子块分配给训练集
<span class="math inline">\(R\)</span>，某些分配给验证集 <span
class="math inline">\(\mathcal V\)</span>；见图
8.4。该过程对每个验证集的 <span class="math inline">\(K\)</span>
个选择重复进行，并对 <span class="math inline">\(K\)</span>
次运行的模型性能取平均值。</p>
<figure>
<img src="./F8.4.png" alt="F8.4" />
<figcaption aria-hidden="true">F8.4</figcaption>
</figure>
<p>我们将数据集划分为两个集合 <span class="math inline">\(D = R \cup
\mathcal V\)</span>，且它们不重叠（<span class="math inline">\(R \cap
\mathcal V = \emptyset\)</span>），其中 <span
class="math inline">\(\mathcal V\)</span> 是验证集，在 <span
class="math inline">\(R\)</span> 上训练模型。训练完成后，我们在验证集
<span class="math inline">\(\mathcal V\)</span> 上评估预测器 <span
class="math inline">\(f\)</span>
的性能（例如，计算训练模型在验证集上的均方根误差
RMSE）。更准确地说，对于每个划分 <span
class="math inline">\(k\)</span>，训练数据 <span
class="math inline">\(R^{(k)}\)</span> 生成预测器 <span
class="math inline">\(f^{(k)}\)</span>，然后将其应用于验证集 <span
class="math inline">\(\mathcal V^{(k)}\)</span> 来计算经验风险 <span
class="math inline">\(R(f^{(k)}, \mathcal
V^{(k)})\)</span>。我们遍历所有可能的训练集与验证集划分，并计算预测器的平均泛化误差。</p>
<p>交叉验证近似期望泛化误差： <span class="math display">\[
\mathbb{E}_\mathcal V [R(f, \mathcal V)] \approx \frac{1}{K}
\sum_{k=1}^{K} R(f^{(k)}, \mathcal V^{(k)}),
\]</span> <strong>其中 <span class="math inline">\(R(f^{(k)}, \mathcal
V^{(k)})\)</span> 是预测器 <span class="math inline">\(f^{(k)}\)</span>
在验证集 <span class="math inline">\(\mathcal V^{(k)}\)</span>
上的风险（例如
RMSE）</strong>(<strong>个人注：这里应该是期望风险？</strong>)。这种近似有两个来源：第一，由于训练集有限，导致无法得到最优的
<span
class="math inline">\(f^{(k)}\)</span>；第二，由于验证集有限，导致对风险
<span class="math inline">\(R(f^{(k)}, \mathcal V^{(k)})\)</span>
的估计不准确。</p>
<p><span class="math inline">\(K\)</span>
折交叉验证的一个潜在缺点是需要训练模型$ K
$次，如果训练成本高，则计算开销很大。在实践中，单看直接参数通常是不够的。例如，我们需要探索多个复杂度参数（如多个正则化参数），这些参数可能不是模型的直接参数。评估依赖这些超参数的模型质量，可能导致训练次数随着模型参数数量呈指数增长。可以使用嵌套交叉验证（Section
8.6.1）来搜索合适的超参数。</p>
<p>然而，交叉验证是一个非常容易并行化的问题，即几乎不需要额外努力就可以将问题拆分成多个并行任务。只要有足够的计算资源（例如云计算或服务器集群），交叉验证的耗时不会超过一次性能评估所需的时间。</p>
<p>在本节中，我们看到经验风险最小化是基于以下几个概念：函数的假设类、损失函数以及正则化。在第
8.3
节中，我们将看到使用概率分布来替代损失函数和正则化这一思想的效果。</p>
<blockquote>
<p>个人注：k折交叉验证会训练出K个不同参数的模型。常用于评估模型的泛化性能，而不是确定最终模型。</p>
<p>详见《k 折交叉验证.md》</p>
</blockquote>
<h4 id="延伸阅读">8.2.5 延伸阅读</h4>
<p>由于经验风险最小化的最初发展（Vapnik,
1998）使用了大量理论化的语言，之后的许多发展也以理论为主。这个研究领域被称为统计学习理论（Vapnik,
1999；Evgeniou 等, 2000；Hastie 等, 2001；von Luxburg 和 Scholkopf,
2011）。最近的一本机器学习教材（Shalev-Shwartz 和 Ben-David,
2014）在理论基础上发展了高效的学习算法。</p>
<p>正则化的概念起源于病态逆问题的求解（Neumaier,
1998）。这里介绍的方法称为 Tikhonov
正则化，同时还有一个紧密相关的受约束版本称为 Ivanov 正则化。Tikhonov
正则化与偏差-方差权衡和特征选择有着深刻的关系（Buhlmann 和 Van De Geer,
2011）。交叉验证的替代方法包括自助法（bootstrap）和留一法（jackknife）（Efron
和 Tibshirani, 1993；Davidson 和 Hinkley, 1997；Hall, 1992）。</p>
<p>将经验风险最小化（第 8.2
节）视为“无概率基础”是不正确的。实际上存在一个未知的概率分布 <span
class="math inline">\(p(x, y)\)</span>
来支配数据生成过程。然而，经验风险最小化的方法对这个分布的选择是不可知的。这与标准统计方法形成对比，后者通常需要明确知道
<span class="math inline">\(p(x, y)\)</span>。此外，由于该分布是样本
<span class="math inline">\(x\)</span> 与标签 <span
class="math inline">\(y\)</span>
的联合分布，标签可以是非确定性的。与标准统计方法不同，我们不需要为标签
<span class="math inline">\(y\)</span> 指定噪声分布。</p>
<h3 id="参数估计">8.3 参数估计</h3>
<p>在第 8.2
节中，我们并没有使用概率分布来明确地对问题建模。在本节中，我们将看到如何使用<strong>概率分布来建模，由于观测过程的不确定性以及预测器参数的不确定性</strong>。在第
8.3.1
节中，我们将介绍<strong>似然函数，它类似于经验风险最小化中损失函数（第
8.2.2 节）的概念。先验的概念（第 8.3.2 节）则类似于正则化（第 8.2.3
节）的概念。</strong></p>
<h4 id="极大似然估计">8.3.1 极大似然估计</h4>
<p>极大似然估计（<span
class="math inline">\(\text{MLE}\)</span>）的核心思想是定义一个<strong>参数的函数</strong>，使我们能够找到能够很好拟合数据的模型。估计问题集中在似然函数上，或者更准确地说，是其负对数。对于由随机变量
<span class="math inline">\(x\)</span> 表示的数据，以及由参数 <span
class="math inline">\(\theta\)</span> 参数化的概率密度族 <span
class="math inline">\(p(x \mid
\theta)\)</span>，<strong>负对数似然函数</strong>定义为： <span
class="math display">\[
L_x(\theta) = - \log p(x \mid \theta). \tag{8.14}
\]</span> <strong>符号 <span class="math inline">\(L_x(\theta)\)</span>
强调了参数 <span class="math inline">\(\theta\)</span> 可变而数据 <span
class="math inline">\(x\)</span>
固定的事实</strong>。在书写负对数似然函数时，我们经常省略对 <span
class="math inline">\(x\)</span> 的引用，因为它实际上是 <span
class="math inline">\(\theta\)</span>
的函数，当上下文中数据的不确定性由随机变量表示时，我们记作 <span
class="math inline">\(L(\theta)\)</span>。</p>
<p>让我们解释在固定 <span class="math inline">\(\theta\)</span>
的情况下，概率密度 <span class="math inline">\(p(x \mid \theta)\)</span>
建模了什么。它是一个用于建模数据不确定性的分布。换句话说，<strong>一旦我们选择了想要作为预测器的函数类型，似然函数就提供了观测数据
<span class="math inline">\(x\)</span> 的概率。</strong></p>
<p>从另一种角度来看，如果我们认为<strong>数据是固定的（因为已经观测到），而我们改变参数
<span class="math inline">\(\theta\)</span>，那么 <span
class="math inline">\(L(\theta)\)</span>
告诉我们什么？它告诉我们，对于观测数据 <span
class="math inline">\(x\)</span>，某个特定的 <span
class="math inline">\(\theta\)</span>
设置有多可能。基于这种观点，极大似然估计器给出了对于该数据集最可能的参数
<span class="math inline">\(\theta\)</span>。</strong></p>
<p>我们考虑监督学习设置，其中得到一组样本对 <span
class="math inline">\((x_1, y_1), \dots, (x_N, y_N)\)</span>，其中 <span
class="math inline">\(x_n \in \mathbb{R}^D\)</span>，标签 <span
class="math inline">\(y_n \in
\mathbb{R}\)</span>。我们的目标是构建一个预测器，它以特征向量 <span
class="math inline">\(x_n\)</span> 作为输入并输出预测 <span
class="math inline">\(y_n\)</span>（或接近 <span
class="math inline">\(y_n\)</span> 的值）。换句话说，给定向量 <span
class="math inline">\(x_n\)</span>，我们希望得到标签 <span
class="math inline">\(y_n\)</span>
的概率分布。换句话说，我们为特定的参数设置 <span
class="math inline">\(\theta\)</span>
指定了标签在样本条件下的条件概率分布。</p>
<blockquote>
<p>个人注：要好好理解上述这段，才能理解最大似然函数的估计。</p>
</blockquote>
<p><strong>例</strong> 8.4</p>
<p>第一个常用的例子是指定在给定样本的情况下，标签的条件概率服从高斯分布。换句话说，我们假设可以用独立的高斯噪声（参考第
6.5 节）来解释观测的不确定性，且噪声均值为零，即 <span
class="math inline">\(\varepsilon_n \sim \mathcal{N}(0,
\sigma^2)\)</span>。我们进一步假设线性模型 <span
class="math inline">\(x_n^\top \theta\)</span>
被用于预测。这意味着我们为每个样本标签对 <span
class="math inline">\((x_n, y_n)\)</span> 指定了高斯似然函数： <span
class="math display">\[
p(y_n \mid x_n, \theta) = \mathcal{N}(y_n \mid x_n^\top \theta,
\sigma^2). \tag{8.15}
\]</span> 图 8.3 展示了给定参数 <span
class="math inline">\(\theta\)</span> 的高斯似然的示意图。我们将在第 9.2
节中看到如何将上述表达式显式地展开为高斯分布的形式。</p>
<blockquote>
<p>个人注：<span
class="math inline">\(\mathcal{N}(y_n∣μ,σ^2)\)</span>的意思是：<strong>在均值为
<span class="math inline">\(\mu\)</span>、方差为 <span
class="math inline">\(\sigma^2\)</span> 的高斯分布下，随机变量取值为
<span class="math inline">\(y_n\)</span> 的概率密度值</strong>。</p>
<p><span class="math inline">\(p(y_n∣x_n,θ)\)</span>理解为
<strong>“在给定输入 <span class="math inline">\(x_n\)</span> 和参数
<span class="math inline">\(\theta\)</span> 的条件下，输出 <span
class="math inline">\(y_n\)</span> 的条件概率密度”</strong>。</p>
</blockquote>
<p>我们假设样本集合 <span class="math inline">\((x_1, y_1), \ldots,
(x_N, y_N)\)</span> 是<strong>独立同分布</strong>( independent
identically distributed and identically distribut)（i.i.d.）的。
“独立”（见第 6.4.5 节）意味着整个数据集的似然（<span
class="math inline">\(Y = \{y_1, \ldots, y_N\}\)</span>，<span
class="math inline">\(X = \{x_1, \ldots,
x_N\}\)</span>）可以分解为各个样本似然的乘积： <span
class="math display">\[
p(Y \mid X, \theta) = \prod_{n=1}^N p(y_n \mid x_n, \theta), \tag{8.16}
\]</span> <strong>其中 <span class="math inline">\(p(y_n \mid x_n,
\theta)\)</span> 是一个特定的分布</strong>（在例 8.4 中是高斯分布）。
“同分布”意味着乘积式 (8.16)
中的每一项都是相同类型的分布，并且它们共享相同的参数。从优化的角度来看，能够分解为多个更简单函数之和的函数通常更容易计算。因此，在机器学习中我们常常考虑<strong>负对数似然</strong>：
<span class="math display">\[
L(\theta) = - \log p(Y \mid X, \theta) = - \sum_{n=1}^N \log p(y_n \mid
x_n, \theta). \tag{8.17}
\]</span> 虽然直观上可能会倾向于这样理解：在条件概率 <span
class="math inline">\(p(y_n \mid x_n, \theta)\)</span> (式 8.15)
中，<span class="math inline">\(\theta\)</span>
出现在条件符号右边，因此应该被看作是“已知且固定”的；但是这种理解是<strong>错误的</strong>。事实上，负对数似然
<span class="math inline">\(L(\theta)\)</span> 是 <span
class="math inline">\(\theta\)</span>
的函数。因此，要找到一个能够很好地解释数据 <span
class="math inline">\((x_1, y_1), \ldots, (x_N, y_N)\)</span> 的参数向量
<span class="math inline">\(\theta\)</span>，需要对 <span
class="math inline">\(\theta\)</span> 最小化负对数似然 <span
class="math inline">\(L(\theta)\)</span>。</p>
<p><strong>备注</strong>：<strong>式 (8.17)
中的负号是历史遗留的约定，这是因为我们希望最大化似然，但数值优化领域通常研究的是函数的最小化。</strong></p>
<blockquote>
<p>个人注：<span
class="math inline">\(L(\theta)\)</span>表示的是整个数据集的联合概率。</p>
</blockquote>
<p><strong>例 8.5</strong> 继续我们关于高斯似然 (8.15)
的例子，负对数似然可以改写为 <span class="math display">\[
\begin{align}
L(\theta) &amp; = -\sum_{n=1}^N \log p(y_n \mid x_n, \theta)
    = -\sum_{n=1}^N \log \mathcal{N}(y_n \mid x_n^\top \theta, \sigma^2)
\tag{8.18a} \\
&amp; = -\sum_{n=1}^N \log \frac{1}{\sqrt{2\pi\sigma^2}}  
    \exp\Bigg(-\frac{(y_n - x_n^\top \theta)^2}{2\sigma^2}\Bigg)
\tag{8.18b} \\
&amp; = -\sum_{n=1}^N \log \exp\Bigg(-\frac{(y_n - x_n^\top
\theta)^2}{2\sigma^2}\Bigg)  
    - \sum_{n=1}^N \log \frac{1}{\sqrt{2\pi\sigma^2}} \tag{8.18c} \\
&amp; = \frac{1}{2\sigma^2} \sum_{n=1}^N (y_n - x_n^\top \theta)^2  
    - \sum_{n=1}^N \log \frac{1}{\sqrt{2\pi\sigma^2}} . \tag{8.18d}
\end{align}
\]</span></p>
<p><strong>由于 <span class="math inline">\(\sigma\)</span> 是给定的，式
(8.18d) 中的第二项是常数，因此最小化 <span
class="math inline">\(L(\theta)\)</span> 等价于解决最小二乘问题（参见
(8.8)），这个问题体现在第一项。</strong></p>
<p>事实证明，对于高斯似然，极大似然估计所对应的优化问题是有闭式解的。我们将在第
9 章中看到更多细节。图 8.5
展示了一个回归数据集以及由最大似然参数所决定的函数。极大似然估计可能会遭遇过拟合（第
8.3.3 节），这与无正则化的经验风险最小化（第 9.2.3
节）类似。对于其他似然函数，也就是说，如果我们用非高斯分布来建模噪声，那么极大似然估计可能就没有解析的闭式解。在这种情况下，我们需要借助第
7 章讨论的数值优化方法。</p>
<p><img src="/img3/机器学习的数学基础Part2/F8.5.png" alt="F8.5" style="zoom:50%;" /></p>
<p><img src="/img3/机器学习的数学基础Part2/F8.6.png" alt="F8.6" style="zoom:50%;" /></p>
<h4 id="最大后验估计">8.3.2 最大后验估计</h4>
<p>Maximum A Posteriori Estimation, MAP</p>
<p>如果我们对参数 <span class="math inline">\(\theta\)</span>
的分布有先验知识，就可以在似然函数中额外引入一项。这个额外的项就是参数的先验概率分布
<span
class="math inline">\(p(\theta)\)</span>。对于给定的先验，在观察到一些数据
<span class="math inline">\(x\)</span> 之后，我们应当如何更新关于 <span
class="math inline">\(\theta\)</span> 的分布呢？换句话说，观察到数据
<span class="math inline">\(x\)</span> 后，我们如何表示自己对 <span
class="math inline">\(\theta\)</span> 有了更具体的认知？正如第 6.3
节所讨论的那样，贝叶斯定理为我们提供了一种系统的方法来<strong>更新随机变量的概率分布</strong>。它允许我们通过先验分布
<span
class="math inline">\(p(\theta)\)</span>（一般性的先验信息）以及把参数
<span class="math inline">\(\theta\)</span> 与观测数据 <span
class="math inline">\(x\)</span> 联系起来的函数 <span
class="math inline">\(p(x \mid
\theta)\)</span>（即似然函数），来计算参数 <span
class="math inline">\(\theta\)</span> 的后验分布 <span
class="math inline">\(p(\theta \mid x)\)</span>（更具体的认知）： <span
class="math display">\[
p(\theta \mid x) = \frac{p(x \mid \theta)p(\theta)}{p(x)} \tag{8.19}
\]</span> 我们感兴趣的是寻找能最大化后验分布的参数 <span
class="math inline">\(\theta\)</span>。由于 <span
class="math inline">\(p(x)\)</span> 与 <span
class="math inline">\(\theta\)</span>
无关，在优化时可以忽略分母，从而得到： <span class="math display">\[
p(\theta \mid x) \propto p(x \mid \theta) p(\theta) \tag{8.20}
\]</span> 上述比例关系隐藏了数据的密度 <span
class="math inline">\(p(x)\)</span>，而它可能是难以估计的。<strong>与其估计负对数似然的最小值，我们现在估计的是负对数后验的最小值，这被称为最大后验估计（Maximum
A Posteriori Estimation, MAP）</strong>。图 8.6
展示了在模型中加入一个均值为零的高斯先验后的效果。</p>
<p><strong>例 8.6</strong>
在前一个例子中假设似然函数是高斯分布的基础上，我们进一步假设参数向量服从零均值的多元高斯分布，即
<span class="math inline">\(p(\theta) = \mathcal{N}(0,
\Sigma)\)</span>，其中 <span class="math inline">\(\Sigma\)</span>
是协方差矩阵（见第 6.5
节）。需要注意的是，高斯分布的共轭先验仍然是高斯分布（见第 6.6.1
节），因此我们预期其后验分布也将是高斯分布。关于最大后验估计的细节将在第
9 章中讨论。</p>
<p>在机器学习中，引入关于“好的参数大致位于何处”的先验知识是非常常见的。另一种观点（见第
8.2.3
节）是正则化，它引入了一个附加项，使得最终得到的参数更倾向于接近原点（个人注：这里的原点应该是指先验分布？）。<strong>最大后验估计可以被视为在非概率方法与概率方法之间架起的一座桥梁：它明确承认了对先验分布的需求，但仍然只给出参数的一个点估计。</strong></p>
<blockquote>
<p>个人注：</p>
<ul>
<li><span class="math inline">\(p(\theta \mid X,y)\)</span> 就是
<strong>参数的后验分布</strong>。</li>
<li>它是贝叶斯统计的核心：不是给一个点估计，而是给一整个分布。</li>
</ul>
</blockquote>
<p><strong>备注</strong>：极大似然估计（<span
class="math inline">\(\text{MLE}） \theta_{ML}\)</span>
具有以下性质（Lehmann 和 Casella, 1998; Efron 和 Hastie, 2016）：</p>
<ul>
<li><p>渐近一致性：当观测数量趋于无穷大时，<span
class="math inline">\(\text{MLE}\)</span>
收敛于真实值，且误差近似服从正态分布。</p></li>
<li><p>为了达到这些性质，所需的样本量可能非常大。</p></li>
<li><p>误差的方差按 <span class="math inline">\(1/N\)</span>
的速度衰减，其中 <span class="math inline">\(N\)</span>
是数据点的数量。</p></li>
<li><p>尤其是在“小数据”情境下，极大似然估计可能会导致过拟合。</p></li>
</ul>
<p><strong>极大似然估计（以及最大后验估计）的原理是利用概率建模来处<em><u>理数据和模型参数中的不确定性</u></em>。然而，我们还没有把概率建模发挥到极致。在本节中，训练过程的结果仍然是得到预测器的一个点估计，也就是说，训练会返回一组单一的参数值，作为最佳预测器的代表。而在第
8.4
节中，我们将采取另一种观点：参数值本身也应当被视为随机变量，并且在预测时，不是去估计该分布的“最佳”值，而是利用完整的参数分布来进行预测。</strong></p>
<h4 id="模型拟合"><strong>8.3.3 模型拟合</strong></h4>
<p>考虑这样一种情形：我们给定了一个数据集，并且希望将一个参数化模型拟合到这些数据上。所谓“拟合”，通常是指通过优化/学习模型参数，使其最小化某个损失函数，例如负对数似然。在极大似然估计（第
8.3.1 节）和最大后验估计（第 8.3.2
节）中，我们已经讨论过两种常用的模型拟合算法。</p>
<p>模型的参数化定义了一个模型类 <span
class="math inline">\(M_\theta\)</span>，我们可以在其中进行操作。例如，在一个线性回归的场景下，我们可以定义输入
<span class="math inline">\(x\)</span> 与（无噪声）观测值 <span
class="math inline">\(y\)</span> 之间的关系为 <span
class="math display">\[
y = ax + b,
\]</span> 其中 <span class="math inline">\(\theta := \{a, b\}\)</span>
是模型参数。在这种情况下，模型参数 <span
class="math inline">\(\theta\)</span>
描述了一族仿射函数，也就是说，一组斜率为 <span
class="math inline">\(a\)</span> 的直线，它们相对于 0 的截距由 <span
class="math inline">\(b\)</span> 决定。假设数据来自某个我们未知的模型
<span
class="math inline">\(M^\ast\)</span>。对于一个给定的训练数据集，我们的目标是优化
<span class="math inline">\(\theta\)</span>，使得 <span
class="math inline">\(M_\theta\)</span> 尽可能接近 <span
class="math inline">\(M^\ast\)</span>，这里的“接近”由我们所优化的目标函数来定义（例如，训练数据上的平方损失）。</p>
<p>图 8.7 展示了一种情形：我们只有一个较小的模型类（由圆圈 <span
class="math inline">\(M_\theta\)</span> 表示），而数据生成模型 <span
class="math inline">\(M^\ast\)</span>
位于所考虑模型集合之外。我们从某个初始参数 <span
class="math inline">\(M_{\theta_0}\)</span>
开始搜索。在完成优化之后，即得到最优参数 <span
class="math inline">\(\theta^\ast\)</span>
之后，我们会区分三种不同的情形：（i）过拟合，（ii）欠拟合，以及（iii）拟合良好。接下来我们将对这三个概念给出高层次的直观解释。</p>
<p><img src="/img3/机器学习的数学基础Part2/F8.7.png" alt="F8.7" style="zoom:50%;" /></p>
<p>粗略来说，<strong>过拟合</strong>是指这样一种情况：参数化的模型类过于复杂，足以拟合由
<span class="math inline">\(M^\ast\)</span>
生成的数据集，换句话说，<span class="math inline">\(M_\theta\)</span>
能够拟合比真实数据复杂得多的数据集。举例来说，如果数据集是由一个线性函数生成的，而我们定义的
<span class="math inline">\(M_\theta\)</span>
是七阶多项式函数类，那么它不仅能拟合线性函数，还能拟合二次、三次，甚至更高阶的多项式。通常，过拟合的模型具有大量的参数。我们经常观察到的一种现象是：过于灵活的模型类
<span class="math inline">\(M_\theta\)</span>
会用尽其建模能力来降低训练误差。如果训练数据中存在噪声，它甚至会在噪声中“发现”一些虚假的有用信号。这将导致在训练数据之外进行预测时出现严重问题。图
8.8(a)
给出了一个回归场景下过拟合的例子，其中模型参数是通过最大似然法（见第
8.3.1 节）学习得到的。我们将在第 9.2.2
节中进一步讨论回归中的过拟合问题。</p>
<figure>
<img src="./F8.8.png" alt="F8.8" />
<figcaption aria-hidden="true">F8.8</figcaption>
</figure>
<p>当我们遇到 <strong>欠拟合</strong> 时，情况则正好相反：模型类 <span
class="math inline">\(M_\theta\)</span>
不够复杂。举个例子，如果我们的数据集是由正弦函数生成的，但 <span
class="math inline">\(\theta\)</span>
只能参数化直线，那么即便采用最优的优化方法，也无法逼近真实模型。不过，我们仍然会去优化参数，找到一条最优的直线来拟合数据集。图
8.8(b)
展示了一个欠拟合的例子，因为模型缺乏足够的灵活性。通常，欠拟合的模型参数较少。第三种情况是
<strong>模型类恰到好处</strong>。此时，我们的模型拟合得比较好，即既没有过拟合，也没有欠拟合。这意味着我们的模型类刚好足够丰富，可以描述给定的数据集。图
8.8(c)
展示了一个较好拟合给定数据集的模型。理想情况下，这就是我们希望使用的模型类，因为它具有良好的泛化能力。在实际应用中，我们经常会定义非常复杂的模型类
<span
class="math inline">\(M_\theta\)</span>，其中包含大量参数，例如深度神经网络。为了缓解过拟合问题，我们可以使用
<strong>正则化</strong>（第 8.2.3 节）或 <strong>先验</strong>（第 8.3.2
节）。我们将在第 8.6 节中讨论如何选择模型类。</p>
<h4 id="延伸阅读-1"><strong>8.3.4 延伸阅读</strong></h4>
<p>在考虑概率模型时，极大似然估计的原理推广了线性模型中最小二乘回归的思想，我们将在第
9
章中详细讨论这一点。当我们将预测器限制为线性形式，并在输出端再施加一个非线性函数
<span class="math inline">\(\phi\)</span> 时，即 <span
class="math display">\[
p(y_n \mid x_n, \theta) = \phi(\theta^\top x_n), \tag{8.21}
\]</span>
我们就可以考虑其他预测任务的模型，例如二分类问题或计数数据建模（McCullagh
和 Nelder，1989）。另一种观点是把这种情形看作是来自
<strong>指数族分布</strong>（第 6.6
节）的似然函数。这类模型中，参数与数据之间具有线性依赖关系，但同时可能包含一个非线性变换
<span class="math inline">\(\phi\)</span>（称为
<strong>链接函数</strong>），被称为
<strong>广义线性模型</strong>（Agresti，2002，第 4
章）。极大似然估计有着悠久的历史，最初是由 Ronald Fisher 爵士在 20 世纪
30 年代提出的。我们将在第 8.4
节中进一步扩展概率模型的思想。在使用概率模型的研究者中，一个长期的争论点是
<strong>贝叶斯统计</strong> 与 <strong>频率学派统计</strong>
的分歧。正如第 6.1.1 节所提到的，争论的核心在于对概率的定义。回忆第 6.1
节中提到的观点：概率可以看作是对逻辑推理的推广（通过引入不确定性）（Cheeseman，1985；Jaynes，2003）。极大似然估计方法在本质上属于频率学派。对有兴趣的读者，可以参考
Efron 和
Hastie（2016），该书对贝叶斯与频率学派两种统计学方法给出了一个较为平衡的视角。需要注意的是，在某些概率模型中，极大似然估计可能不可行。对于这类情况，读者可以参考更高阶的统计教材，例如
Casella 和 Berger（2002），其中介绍了诸如
<strong>矩估计法</strong>、<strong>M-估计</strong> 和
<strong>估计方程</strong> 等方法。</p>
<h3 id="概率建模与推断"><strong>8.4 概率建模与推断</strong></h3>
<p>在机器学习中，我们经常关心的是数据的解释和分析，例如预测未来事件和进行决策。为了让这项任务更易处理，我们通常会建立一些模型来描述生成观测数据的生成过程。例如，我们可以用两步来描述一次抛硬币实验的结果（“正面”或“反面”）。第一步，我们定义一个参数
<span class="math inline">\(\mu\)</span>，它作为伯努利分布（第 6
章）的参数，表示硬币出现“正面”的概率；第二步，我们可以从伯努利分布 <span
class="math inline">\(p(x \mid \mu) = \mathrm{Ber}(\mu)\)</span>
中采样一个结果 <span class="math inline">\(x \in {\text{正面},
\text{反面}}\)</span>。参数 <span class="math inline">\(\mu\)</span>
决定了一个特定的数据集 <span
class="math inline">\(X\)</span>，并取决于所用的硬币。由于 <span
class="math inline">\(\mu\)</span>
是事先未知的，且无法被直接观测到，因此我们需要一些机制来在给定抛硬币实验观测结果的情况下，学习关于
<span class="math inline">\(\mu\)</span>
的信息。在接下来的讨论中，我们将说明如何利用概率建模来实现这一目的。</p>
<h4 id="概率模型"><strong>8.4.1 概率模型</strong></h4>
<p>概率模型将实验中不确定的部分表示为概率分布。使用概率模型的好处在于，它们提供了一套统一且一致的概率论工具（第
6 章），可用于建模、推断、预测以及模型选择。在概率建模中，观测变量 <span
class="math inline">\(x\)</span> 和隐藏参数 <span
class="math inline">\(\theta\)</span> 的联合分布 <span
class="math inline">\(p(x, \theta)\)</span>
占据核心地位：它包含了以下几方面的信息：</p>
<ul>
<li><strong>先验与似然</strong>（乘法规则，第 6.3 节）；</li>
<li><strong>边际似然</strong> <span
class="math inline">\(p(x)\)</span>，在模型选择中将发挥重要作用（第 8.6
节），它可以通过对联合分布对参数进行积分（求和规则，第 6.3
节）来计算；</li>
<li><strong>后验分布</strong>，它可以通过将联合分布除以边际似然得到。</li>
</ul>
<p>只有联合分布具有这样的性质。因此，一个概率模型就是由其所有随机变量的联合分布所刻画的。</p>
<h4 id="贝叶斯推断"><strong>8.4.2 贝叶斯推断</strong></h4>
<p>机器学习中的一个关键任务是，利用模型和数据来揭示模型的隐藏变量（参数）<span
class="math inline">\(\theta\)</span> 的取值，前提是我们已经观测到了变量
<span class="math inline">\(x\)</span>。在 8.3.1 节
中，我们已经讨论了两种估计模型参数 <span
class="math inline">\(\theta\)</span>
的方法：极大似然估计（MLE）和最大后验估计（MAP）。在这两种情况下，我们都得到
<span class="math inline">\(\theta\)</span>
的一个最优点估计值，因此，参数估计的核心算法问题就转化为一个优化问题。一旦得到了这些点估计
<span
class="math inline">\(\theta^*\)</span>，我们就可以利用它们进行预测。更具体地，<em><u><strong>预测分布</strong></u></em>为
<span class="math display">\[
p(x \mid \theta^*),
\]</span> 其中我们在似然函数中使用 <span
class="math inline">\(\theta^*\)</span>。</p>
<p>然而，正如在 6.3 节
中讨论的，仅仅关注后验分布中的某个统计量（比如最大化后验的参数 <span
class="math inline">\(\theta^*\)</span>），会导致信息丢失。而这种信息丢失在需要基于预测
<span class="math inline">\(p(x \mid \theta^*)\)</span>
来进行决策的系统中可能非常关键。<strong>这类决策系统通常具有与似然函数不同的目标函数，比如平方误差损失或分类错误率。因此，保留完整的后验分布会非常有用，并能带来更稳健的决策。贝叶斯推断的核心就是寻找这个后验分布（Gelman
等，2004）。</strong></p>
<blockquote>
<p>个人注：似然函数是损失函数的一种，在优化过程中使用；而目标函数是预测结果的准确率。</p>
</blockquote>
<p>对于一个数据集 <span
class="math inline">\(X\)</span>，给定参数的先验分布 <span
class="math inline">\(p(\theta)\)</span> 和似然函数，后验分布为 <span
class="math display">\[
p(\theta \mid X) = \frac{p(X \mid \theta)p(\theta)}{p(X)},
\quad
p(X) = \int p(X \mid \theta)p(\theta) \, d\theta, \tag{8.22}
\]</span> 这是通过应用 <strong>贝叶斯定理</strong>
得到的。关键思想是利用贝叶斯定理，把参数 <span
class="math inline">\(\theta\)</span> 和数据 <span
class="math inline">\(X\)</span> 之间的关系反转过来（原本是似然函数
<span class="math inline">\(p(X \mid \theta)\)</span>
给出的），从而得到后验分布 <span class="math inline">\(p(\theta \mid
X)\)</span>。拥有参数的后验分布的意义在于，它可以将参数的不确定性传播到数据层面。更具体地说，当参数具有分布
<span class="math inline">\(p(\theta)\)</span> 时，我们的预测为 <span
class="math display">\[
p(x) = \int p(x \mid \theta) p(\theta) \, d\theta
= \mathbb{E}_\theta \big[ p(x \mid \theta) \big], \tag{8.23}
\]</span> 这样，<strong>预测就不再依赖于某个固定的模型参数 <span
class="math inline">\(\theta\)</span>，因为它们已经被边缘化/积分消去了。</strong>式
(8.23) 揭示了预测是对所有可能的参数取值 <span
class="math inline">\(\theta\)</span>
的加权平均，其中参数的“合理性”由参数分布 <span
class="math inline">\(p(\theta)\)</span> 体现。</p>
<blockquote>
<p>边缘化/积分；边缘化等价于积分掉！</p>
</blockquote>
<blockquote>
<p>个人注：：<strong>预测分布和预测的“点值”是不同概念</strong>：</p>
<ul>
<li><span class="math inline">\(p(x \mid \theta^*)\)</span>
是一个<strong>分布</strong>，描述在固定参数下，新数据 <span
class="math inline">\(x\)</span> 出现的可能性。</li>
<li>即便参数确定了，数据本身可能是随机的（比如高斯回归里 <span
class="math inline">\(y \sim \mathcal{N}(x^\top \theta^*,
\sigma^2)\)</span>），所以我们仍然得到一个概率分布而不是单个数值。</li>
</ul>
</blockquote>
<p>在 8.3 节
我们讨论了参数估计，而在这里讨论了贝叶斯推断，现在让我们比较一下这两种学习方法。通过极大似然估计（MLE）或最大后验估计（MAP）进行的<strong>参数估计，</strong>会<strong>给出参数的一个一致的点估计
<span
class="math inline">\(\theta^*\)</span>，其核心计算问题是一个优化问题</strong>。相比之下，<strong>贝叶斯推断给出的是一个（后验）分布，其核心计算问题则是一个积分问题。</strong>基于点估计的预测相对直接，而在贝叶斯框架下的预测则需要解决另一个积分问题（见公式
(8.23)）。然而，贝叶斯推断为我们提供了一种有原则的方法来：</p>
<ul>
<li>融合先验知识，</li>
<li>考虑额外的辅助信息，</li>
<li>融合结构化知识，</li>
</ul>
<p>这些在参数估计框架中并不容易实现。此外，将参数不确定性传播到预测中，在需要进行风险评估和探索的决策系统（尤其是在数据高效学习的背景下，见
Deisenroth 等，2015；Kamthe 和
Deisenroth，2018）中非常有价值。尽管贝叶斯推断是一个在数学上有原则的框架，用于学习参数并进行预测，但它也带来了一些实际挑战，主要是因为需要解决积分问题（见公式
(8.22) 和 (8.23)）。更具体地说，如果我们没有为参数选择一个共轭先验（见
6.6.1 节），那么 (8.22) 和 (8.23)
中的积分通常在解析上是不可解的，我们就无法以封闭形式计算后验、预测或边际似然。在这种情况下，我们必须借助近似方法。例如，可以采用
<strong>随机近似方法</strong>，如
<strong>马尔可夫链蒙特卡罗（MCMC）</strong>（Gilks 等，1996）；或者
<strong>确定性近似方法</strong>，如
<strong>拉普拉斯近似</strong>（Bishop, 2006; Barber, 2012; Murphy,
2012）、<strong>变分推断</strong>（Jordan 等, 1999; Blei 等, 2017）或
<strong>期望传播</strong>（Minka,
2001a）。尽管存在这些挑战，贝叶斯推断已经在许多问题中取得了成功应用，包括：</p>
<ul>
<li>大规模主题建模（Hoffman 等, 2013），</li>
<li>点击率预测（Graepel 等, 2010），</li>
<li>控制系统中的高效数据利用的强化学习（Deisenroth 等, 2015），</li>
<li>在线排序系统（Herbrich 等, 2007），</li>
<li>大规模推荐系统。</li>
</ul>
<p>此外，还存在一些通用工具，例如 <strong>贝叶斯优化</strong>（Brochu
等, 2009; Snoek 等, 2012; Shahriari 等,
2016），它们在高效搜索模型或算法的元参数（meta
parameters）时非常有用。</p>
<p><strong>备注：</strong>在机器学习文献中，“（随机）变量（variables）”与“参数（parameters）”之间的区分有时是相对随意的。通常情况下，参数是通过估计得到的（例如最大似然），而变量则通常被边缘化处理。在本书中，我们并不严格区分二者，因为<strong>原则上我们可以为任何参数设定一个先验并将其积分消去</strong>，这样根据上述区分，该参数就会转化为一个随机变量。</p>
<blockquote>
<p>个人注：最小二乘估计的参数和预测的结果都是固定的（点估计），最大似然和最大后验估计的参数是固定的（点估计）而预测结果是一个分布；贝叶斯推断的参数和预测结果都是分布；</p>
<p>详见《点估计和分布估计.md》</p>
</blockquote>
<h4 id="潜变量模型"><strong>8.4.3 潜变量模型</strong></h4>
<p>Latent-Variable Models</p>
<p><strong>在实际应用中，有时在模型中加入额外的潜变量 <span
class="math inline">\(z\)</span>（除了模型参数 <span
class="math inline">\(\theta\)</span> 之外）是有用的（Moustaki 等,
2015）。这些潜变量不同于模型参数 <span
class="math inline">\(\theta\)</span>，因为它们并不显式地对模型进行参数化。潜变量可以描述数据生成过程，从而增加模型的可解释性。它们还通常能简化模型结构，使我们可以定义更简单且更丰富的模型结构。</strong>模型结构的简化通常伴随着模型参数数量的减少（Paquet,
2008; Murphy, 2012）。</p>
<p>在潜变量模型中进行学习（至少通过最大似然方法）可以通过
<strong>期望最大化（EM）算法</strong>（Dempster 等, 1977; Bishop,
2006）以有原则的方式进行。潜变量有帮助的例子包括：</p>
<ul>
<li>用于降维的主成分分析（第 10 章）</li>
<li>用于密度估计的高斯混合模型（第 11 章）</li>
<li>用于时间序列建模的隐马尔可夫模型（Maybeck,
1979）或动力系统（Ghahramani 和 Roweis, 1999; Ljung, 1999）</li>
<li>元学习和任务泛化（Hausman 等, 2018; Sæmundsson 等, 2018）</li>
</ul>
<p>尽管引入这些潜变量可能使模型结构和生成过程更容易理解，但潜变量模型的学习通常仍然很困难，这将在第
11 章中进一步讨论。</p>
<p>由于潜变量模型也允许我们定义从参数生成数据的过程，让我们来看这个生成过程。用
<span class="math inline">\(x\)</span> 表示数据，<span
class="math inline">\(\theta\)</span> 表示模型参数，<span
class="math inline">\(z\)</span> 表示潜变量，则条件分布为 <span
class="math display">\[
p(x \mid \theta, z) \tag{8.24}
\]</span> 它允许我们在任意给定的模型参数和潜变量下生成数据。由于 <span
class="math inline">\(z\)</span> 是潜变量，我们会为其设定一个先验 <span
class="math inline">\(p(z)\)</span>。</p>
<p>正如前面讨论的模型一样，具有潜变量的模型也可以在 8.3 和 8.4.2
节讨论的框架下，用于参数学习和推断。为了便于学习（例如通过极大似然估计或贝叶斯推断），我们遵循一个两步程序：</p>
<ol type="1">
<li>首先，计算模型的似然 <span class="math inline">\(p(x \mid
\theta)\)</span>，它不依赖于潜变量；</li>
<li>然后，使用这个似然进行参数估计或贝叶斯推断，此时分别使用 8.3 和
8.4.2 节中完全相同的表达式。</li>
</ol>
<p>由于似然函数 <span class="math inline">\(p(x \mid \theta)\)</span>
是在给定模型参数下的预测分布，我们需要对潜变量进行边缘化，使得 <span
class="math display">\[
p(x \mid \theta) = \int p(x \mid \theta, z) p(z) \, dz, \tag{8.25}
\]</span> 其中 <span class="math inline">\(p(x \mid \theta, z)\)</span>
如公式 (8.24) 所示，<span class="math inline">\(p(z)\)</span>
是潜变量的先验。注意，似然函数必须 不依赖潜变量 <span
class="math inline">\(z\)</span>，而只是数据 <span
class="math inline">\(x\)</span> 和模型参数 <span
class="math inline">\(\theta\)</span> 的函数。公式 (8.25)
中的似然函数可以直接用于通过最大似然进行参数估计。在模型参数 <span
class="math inline">\(\theta\)</span> 上加上先验后，如 8.3.2 节
所述，最大后验估计也同样直接可行。此外，对于潜变量模型，利用似然函数
(8.25) 进行贝叶斯推断（见 8.4.2
节）也是按常规方式进行的：我们在模型参数上设定先验 <span
class="math inline">\(p(\theta)\)</span>，然后利用贝叶斯定理得到数据集
<span class="math inline">\(X\)</span> 下模型参数的后验分布 <span
class="math display">\[
p(\theta \mid X) = \frac{p(X \mid \theta)p(\theta)}{p(X)} \tag{8.26}
\]</span> 公式 (8.26) 中的后验分布可以用于贝叶斯推断框架下的预测，见公式
(8.23)。在潜变量模型中，一个挑战是似然函数 <span
class="math inline">\(p(X \mid \theta)\)</span> 需要根据公式 (8.25)
对潜变量进行边缘化。除非我们为 <span class="math inline">\(p(x \mid z,
\theta)\)</span> 选择共轭先验 <span
class="math inline">\(p(z)\)</span>，否则公式 (8.25)
中的边缘化在解析上是不可解的，我们必须采用近似方法（Bishop, 2006;
Paquet, 2008; Murphy, 2012; Moustaki 等, 2015）。类似于参数后验
(8.26)，我们可以计算潜变量的后验分布： <span class="math display">\[
p(z \mid X) = \frac{p(X \mid z)p(z)}{p(X)}, \quad
p(X \mid z) = \int p(X \mid z, \theta)p(\theta) \, d\theta, \tag{8.27}
\]</span> 其中 <span class="math inline">\(p(z)\)</span>
是潜变量的先验，而 <span class="math inline">\(p(X \mid z)\)</span>
需要对模型参数 <span class="math inline">\(\theta\)</span>
进行积分边缘化。<strong>由于解析求解积分非常困难，可以看出一般情况下同时对潜变量和模型参数进行边缘化是不可能的</strong>（Bishop,
2006; Murphy,
2012）。一个相对容易计算的量是条件于模型参数的潜变量后验分布，即 <span
class="math display">\[
p(z \mid X, \theta) = \frac{p(X \mid z, \theta)p(z)}{p(X \mid \theta)},
\tag{8.28}
\]</span> 其中 <span class="math inline">\(p(z)\)</span>
是潜变量的先验，<span class="math inline">\(p(X \mid z, \theta)\)</span>
如公式 (8.24) 所示。在第 10 章和第 11 章中，我们将分别推导
<strong>PCA</strong> 和 <strong>高斯混合模型</strong>
的似然函数。此外，我们还将计算 PCA 和高斯混合模型中潜变量的后验分布
(8.28)。</p>
<p><strong>备注。</strong> 在后续章节中，我们可能不会对潜变量 <span
class="math inline">\(z\)</span> 和不确定的模型参数 <span
class="math inline">\(\theta\)</span>
做严格区分，也可能将模型参数称为“潜在”或“隐藏”，因为它们未被观测到。在第
10 章和第 11 章中，当使用潜变量 <span class="math inline">\(z\)</span>
时，我们会注意区分两种不同类型的隐藏变量：模型参数 <span
class="math inline">\(\theta\)</span> 和潜变量 <span
class="math inline">\(z\)</span>。</p>
<p>我们可以利用概率模型中所有元素都是随机变量的事实，为它们定义一种统一的表示语言。在
8.5 节
中，我们将看到一种简明的图形语言，用于表示概率模型的结构，并将在后续章节中用这种图形语言描述概率模型。</p>
<h4 id="延伸阅读-2"><strong>8.4.4 延伸阅读</strong></h4>
<p>机器学习中的概率模型（Bishop, 2006；Barber, 2012；Murphy,
2012）为用户提供了一种有原则的方式，用于捕捉数据和预测模型的不确定性。Ghahramani（2015）对机器学习中的概率模型做了简要综述。对于一个给定的概率模型，我们有时幸运地可以解析地计算出感兴趣的参数。然而，一般情况下，解析解是很少的，因此通常采用计算方法，例如采样（Gilks
等, 1996；Brooks 等, 2011）和变分推断（Jordan 等, 1999；Blei 等,
2017）。Moustaki 等（2015）和
Paquet（2008）对潜变量模型中的贝叶斯推断提供了很好的概述。近年来，出现了若干编程语言，旨在将软件中定义的变量视为对应概率分布的随机变量。其目标是能够编写概率分布的复杂函数，同时在底层由编译器自动处理贝叶斯推断的规则。这个快速发展的领域被称为概率编程（probabilistic
programming）。</p>
<h3 id="有向图模型"><strong>8.5 有向图模型</strong></h3>
<p><strong>Directed Graphical Models</strong></p>
<p>在本节中，我们介绍一种用于指定概率模型的图形化语言，称为
有向图模型（Directed Graphical
Model）。它提供了一种紧凑且简明的方式来表示概率模型，并允许读者直观地解析随机变量之间的依赖关系。图模型通过可视化方式捕捉了所有随机变量的联合分布如何分解为仅依赖于部分变量的因子的乘积。</p>
<p>在 8.4 节
中，我们指出<strong>概率模型的联合分布是关键的量</strong>，因为它包含了关于先验、似然和后验的信息。然而，单独的联合分布可能非常复杂，并且并不能告诉我们概率模型的结构特性。例如，联合分布
<span class="math inline">\(p(a, b, c)\)</span>
并不能告诉我们变量之间的独立性关系。这时，图模型就派上用场了。本节依赖于
<strong>独立性和条件独立性</strong> （ independence and conditional
independence）的概念，如 6.4.5 节 所述。</p>
<p><img src="/img3/机器学习的数学基础Part2/F8.9.png" alt="F8.9" style="zoom:50%;" /></p>
<p>在图模型中，节点表示随机变量。在图 8.9(a)
中，<strong>节点表示随机变量 <span class="math inline">\(a, b,
c\)</span>。边表示变量之间的概率关系，例如条件概率。</strong></p>
<p><strong>备注</strong>：并非每个分布都可以在特定的图模型中表示。关于这方面的讨论可以参见
Bishop (2006)。概率图模型具有一些便利的特性：</p>
<ul>
<li>它们是一种简单的方式，用于可视化概率模型的结构。</li>
<li>可以用于设计或激发新的统计模型。</li>
<li>仅通过观察图形，就能对模型的性质（例如条件独立性）获得直观理解。</li>
<li>统计模型中用于推断和学习的复杂计算，可以通过图形操作来表达。</li>
</ul>
<h4 id="图的语义">8.5.1 图的语义</h4>
<p>Graph Semantics</p>
<p>有向图模型/贝叶斯网络(Directed graphical models/Bayesian
networks)是一种用于表示概率模型中<strong>条件依赖关系</strong>的方法。它们通过图形方式描述条件概率，从而为复杂的相互依赖关系提供了一种简洁的语言。同时，这种模块化的描述也带来了计算上的简化。两个节点（随机变量）之间的有向边（箭头）表示条件概率。例如，图
8.9(a) 中从 <span class="math inline">\(a\)</span> 指向 <span
class="math inline">\(b\)</span> 的箭头表示在给定 <span
class="math inline">\(a\)</span> 的情况下，<span
class="math inline">\(b\)</span> 的条件概率 <span
class="math inline">\(p(b \mid
a)。\)</span>如果我们了解联合分布的某些分解形式，就可以从中推导出有向图模型。</p>
<p><strong>例 8.7</strong></p>
<p>考虑三个随机变量 <span class="math inline">\(a, b, c\)</span>
的联合分布： <span class="math display">\[
p(a, b, c) = p(c \mid a, b)\, p(b \mid a)\, p(a) \tag{8.29}
\]</span> 联合分布 (8.29)
的分解告诉了我们关于这些随机变量之间关系的一些信息：</p>
<ul>
<li><span class="math inline">\(c\)</span> 直接依赖于 <span
class="math inline">\(a\)</span> 和 <span
class="math inline">\(b\)</span>；</li>
<li><span class="math inline">\(b\)</span> 直接依赖于 <span
class="math inline">\(a\)</span>；</li>
<li><span class="math inline">\(a\)</span> 不依赖于 <span
class="math inline">\(b\)</span> 也不依赖于 <span
class="math inline">\(c\)</span>。</li>
</ul>
<p>对于分解式 (8.29)，我们得到的有向图模型如图 8.9(a) 所示。</p>
<p>一般来说，我们可以根据分解后的联合分布来构造相应的有向图模型，方法如下：</p>
<ol type="1">
<li>为所有随机变量创建一个节点。</li>
<li>对于每一个条件分布，在图中添加一条从条件变量对应节点指向该变量节点的有向边（箭头）。</li>
</ol>
<p><strong>图的布局取决于联合分布的分解方式。</strong>我们刚刚讨论了如何从一个已知的联合分布分解推导出相应的有向图模型。接下来，我们将做相反的事情：描述如何从一个给定的图模型中提取一组随机变量的联合分布。</p>
<p><strong>例 8.8</strong> 观察图 8.9(b)
中的图模型，我们利用以下两个性质：</p>
<ul>
<li>我们要求的联合分布 <span class="math inline">\(p(x_1, \ldots,
x_5)\)</span>
是一组条件分布的乘积，每个图中的节点对应一个条件分布。在本例中，我们需要五个条件分布（个人注：3个条件分布加上2个独立分布）。</li>
<li>每个条件分布只依赖于图中该节点的父节点。例如，<span
class="math inline">\(x_4\)</span> 依赖于 <span
class="math inline">\(x_2\)</span>。</li>
</ul>
<p>利用这两个性质，我们可以得到联合分布的分解形式： <span
class="math display">\[
p(x_1, x_2, x_3, x_4, x_5) = p(x_1)p(x_5)p(x_2 \mid x_5)p(x_3 \mid x_1,
x_2)p(x_4 \mid x_2). \tag{8.30}
\]</span></p>
<p>一般来说，联合分布 <span class="math display">\[
p(x) = p(x_1, \dots, x_K)
\]</span> 可以写作 <span class="math display">\[
p(x) = \prod_{k=1}^K p(x_k \mid \text{Pa}_k), \tag{8.31}
\]</span> 其中 <span class="math inline">\(\text{Pa}_k\)</span> 表示
“<span class="math inline">\(x_k\)</span>
的父节点”。父节点是指<strong>有</strong>箭头指向 <span
class="math inline">\(x_k\)</span> 的节点。</p>
<p>我们用一个具体的抛硬币实验来结束这一小节。考虑一个伯努利实验（例
6.8），在该实验中结果 <span class="math inline">\(x\)</span>
为“正面”的概率是 <span class="math display">\[
p(x \mid \mu) = \text{Ber}(\mu). \tag{8.32}
\]</span> 现在我们将这个实验重复 <span class="math inline">\(N\)</span>
次，并观测到结果 <span class="math inline">\(x_1, \dots,
x_N\)</span>，于是我们得到联合分布： <span class="math display">\[
p(x_1, \dots, x_N \mid \mu) = \prod_{n=1}^N p(x_n \mid \mu). \tag{8.33}
\]</span>
右边的表达式是对每个单次结果的伯努利分布的乘积，这是因为这些实验相互独立。回顾第
6.4.5
节，<strong>统计独立意味着分布可以因式分解</strong>(个人注：因式分解是指联合分布)。为了把这种情况写成图模型，我们需要区分
未观测/潜在变量和观测变量（unobserved/latent variables and observed
variables）。在图中，观测变量用阴影节点表示，于是我们得到图 8.10(a)
所示的模型。</p>
<p><img src="/img3/机器学习的数学基础Part2/F8.10.png" alt="F8.10" style="zoom:100%;" /></p>
<p>我们看到，单一参数 <span class="math inline">\(\mu\)</span> 对所有
<span class="math inline">\(x_n, n=1, \dots, N\)</span>
都相同，因为这些观测结果是同分布的。一个更简洁但等价的图模型如图 8.10(b)
所示，我们使用 <strong>板式记号（plate
notation）</strong>。板（方框）表示其中的所有内容（在这里是观测值 <span
class="math inline">\(x_n\)</span>）重复 <span
class="math inline">\(N\)</span>
次。因此，这两种图模型是等价的，但板式记号更简洁。图模型还可以立即让我们在
<span class="math inline">\(\mu\)</span> 上引入一个
超先验（hyperprior）。超先验是对第一层先验的参数再加一层先验分布。在图
8.10(c) 中，我们对潜在变量 <span class="math inline">\(\mu\)</span>
施加了一个 <span class="math inline">\(\text{Beta}(\alpha,
\beta)\)</span> 先验。<strong>如果我们把 <span
class="math inline">\(\alpha\)</span> 和 <span
class="math inline">\(\beta\)</span>
看作确定性参数（即非随机变量），那么就省略其周围的圆圈。</strong></p>
<h4 id="条件独立与-d-分离">8.5.2 条件独立与 d-分离</h4>
<p>有向图模型（Directed Graphical
Models）使我们仅通过观察图，就能找到联合分布的条件独立性（第 6.4.5
节）关系属性。一个称为 d-分离（d-separation, Pearl,
1988）的概念对此至关重要。</p>
<p>考虑一个一般的有向图，其中 A, B, C
是不相交的任意节点集合（它们的并集可能小于整个图的节点集合）。我们希望确定一个特定的条件独立性陈述是否成立：“在给定
C 的条件下，A 与 B 条件独立”，记作</p>
<p><span class="math display">\[
A \perp\!\!\!\perp B \mid C \tag{8.34}
\]</span>
该条件独立性是否由一个给定的<strong>有向无环图</strong>所蕴含？为此，我们考虑从
A 中的任意节点到 B
中任意节点的所有可能路径（trail，指忽略箭头方向的路径）。如果一条路径<strong>包含某个节点</strong>，并且满足以下<strong>任意一个条件</strong>，则该路径被称为<strong>阻塞</strong>（blocked）：</p>
<ol type="1">
<li>在该节点上，路径的箭头是 <strong>尾对头</strong> 或
<strong>尾对尾</strong> 相接，并且该节点属于集合 C。</li>
<li>在该节点上，路径的箭头是 <strong>头对头</strong>
相接，并且该节点以及它的所有后代都不属于集合 C。</li>
</ol>
<p>如果所有路径都被阻塞，那么称 A和B被C
<strong>d-分离</strong>（d-separated），并且图中所有变量的联合分布将满足
<span class="math display">\[
A \perp\!\!\!\perp B \mid C
\]</span></p>
<p><img src="/img3/机器学习的数学基础Part2/F8.11.png" alt="F8.11" style="zoom:60%;" /></p>
<p><strong>例 8.9 （条件独立）</strong></p>
<p>考虑图 8.11 中的图模型。通过直接观察，我们得到： <span
class="math display">\[
\begin{align}
b \perp\!\!\!\perp d \mid a, c \tag{8.35}\\
a \perp\!\!\!\perp c \mid b \tag{8.36}\\
b \not\!\perp\!\!\!\perp d \mid c \tag{8.37}\\
a \not\!\perp\!\!\!\perp c \mid b, e \tag{8.38}
\end{align}
\]</span></p>
<blockquote>
<p>个人注：自己对d-分离理解还是不够透彻。详见《d-分离 (d-separation)
.md》和《条件独立.md》</p>
</blockquote>
<p>有向图模型能够对概率模型进行紧凑表示，我们将在第 9、10 和 11
章中看到有向图模型的实例。这种表示形式结合条件独立的概念，使我们能够将相应的概率模型分解成更容易优化的表达式。概率模型的图示表示还能让我们直观地看到建模设计选择对模型结构的影响。我们通常需要对模型结构做出一些高层次的假设。这些建模假设（即超参数hyperparameters）会影响预测性能，但不能直接通过之前介绍的方法来选择。我们将在第
8.6 节讨论选择模型结构的不同方法。</p>
<h4 id="延伸阅读-3">8.5.3 延伸阅读</h4>
<p>关于概率图模型的入门介绍，可以参考 Bishop (2006，第 8
章)；关于其不同应用及相应算法含义的更全面描述，可以参考 Koller 和
Friedman (2009) 的著作。<strong>概率图模型主要有三类</strong>：</p>
<ul>
<li>有向图模型（贝叶斯网络）Directed graphical models (Bayesian
networks)；见图 8.12(a)</li>
<li>无向图模型（马尔可夫随机场）Undirected graphical models (Markov
random fields)；见图 8.12(b)</li>
<li>因子图factor graph；见图 8.12(c)</li>
</ul>
<p><img src="/Users/hongyuanjiao/Desktop/《机器学习的数学基础》Part2/F8.12.png" alt="F8.12" style="zoom:67%;" /></p>
<p>概率图模型支持基于图的推断与学习算法，例如局部信息传递。其应用范围十分广泛，从在线游戏排名
(Herbrich 等,
2007)，到计算机视觉（如图像分割、语义标注、图像去噪、图像修复 (Kittler
和 Foglein, 1984; Sucar 和 Gillies, 1994; Shotton 等, 2006; Szeliski 等,
2008)），再到编码理论 (McEliece 等, 1998)、解线性方程组 (Shental 等,
2008)、以及信号处理中迭代的贝叶斯状态估计 (Bickson 等, 2007; Deisenroth
和 Mohamed, 2012)。</p>
<p>在实际应用中，有一个特别重要但本书未展开讨论的话题是<strong>结构化预测</strong>（structured
prediction） (Bakir 等, 2007; Nowozin 等,
2014)。它使机器学习模型能够处理带有结构的预测任务，例如序列、树和图。神经网络模型的普及使更灵活的概率模型得以应用，从而带来了许多结构化模型的有用应用
(Goodfellow 等, 2016，第 16 章)。</p>
<blockquote>
<p>个人注：<strong>结构化预测</strong>是指非参数的模型吗？</p>
</blockquote>
<p>近年来，概率图模型因其在因果推断中的应用而重新引起了广泛关注 (Pearl,
2009; Imbens 和 Rubin, 2015; Peters 等, 2017; Rosenbaum, 2017)。</p>
<h3 id="模型选择">8.6 模型选择</h3>
<p>在机器学习中，我们常常需要做出一些高层次的建模决策，而这些决策会对模型的性能产生关键性的影响。我们所做的选择（例如，似然函数的形式）会影响模型中自由参数的数量和类型，从而也影响模型的灵活性与表达能力。更复杂的模型往往更灵活，因为它们能够描述更多样的数据集。</p>
<p>例如，次数为 1 的多项式（直线 <span class="math inline">\(y = a_0 +
a_1x\)</span>）只能用来描述输入 <span class="math inline">\(x\)</span>
与观测值 <span class="math inline">\(y\)</span> 之间的线性关系。而次数为
2 的多项式则还能额外描述输入与观测之间的二次关系。</p>
<p>此时，人们可能会认为，越灵活的模型一般越优越，因为它们更具表达能力。然而，一个普遍的问题在于，在训练过程中，我们只能使用训练集来评估模型性能并学习其参数。然而，训练集上的性能并不是我们真正关心的。在第
8.3
节中，我们已经看到极大似然估计可能会导致过拟合，尤其是在训练数据集较小时更为明显。理想情况下，我们的模型在测试集（训练时不可用）上也应当表现良好。<strong>因此，我们需要一些机制来评估模型对未见过的测试数据的泛化能力。<em><u>模型选择</u></em>研究的正是这个问题。</strong></p>
<h4 id="嵌套交叉验证">8.6.1 嵌套交叉验证</h4>
<p>我们之前已经看到过一种可用于模型选择的方法（第 8.2.4
节中的交叉验证）。回顾一下，交叉验证通过反复将数据集划分为训练集和验证集，来估计泛化误差。我们可以再应用一次这个想法，也就是说，对每一次划分，我们再进行一轮交叉验证。这有时被称为<strong>嵌套交叉验证</strong>（见图
8.13）。</p>
<p><img src="/img3/机器学习的数学基础Part2/F8.13.png" alt="F8.13" style="zoom:67%;" /></p>
<p>内层( inner cross-validation
level)用于估计某个特定模型或超参数在内部验证集上的表现。外层( outer
level)用于估计由内层选择出的最优模型的泛化性能。我们可以在<strong>内层测试不同的模型和超参数选择</strong>。为了区分这两个层次，用于估计泛化性能的集合通常称为<strong>测试集</strong>(
test
set)，而用于选择最佳模型的集合称为<strong>验证集</strong>(validation
set)。</p>
<p>内层循环通过近似计算验证集上的经验误差，来估计给定模型的期望泛化误差（公式
8.39）： <span class="math display">\[
E_{\mathcal V} [R(\mathcal V | M)] \approx \frac{1}{K} \sum_{k=1}^{K}
R(\mathcal V^{(k)} | M), \tag{8.39}
\]</span> 其中 <span class="math inline">\(R(\mathcal V | M)\)</span>
是模型 <span class="math inline">\(M\)</span> 在验证集 <span
class="math inline">\(\mathcal V\)</span>
上的经验风险（例如均方根误差）。我们对所有模型重复这个过程，并选择表现最好的模型。</p>
<p>需要注意的是，交叉验证不仅能给出期望泛化误差，还能得到高阶统计量，例如标准误差，它能够衡量均值估计的不确定性。</p>
<p>一旦模型被选定，我们就可以在测试集上评估最终性能。</p>
<blockquote>
<p>个人注：</p>
<p><strong>普通交叉验证</strong>：常用于评估模型的泛化性能，然后对不同的假设（模型）的性能做对比，不是确定最终模型。</p>
<p><strong>嵌套交叉验证</strong>：主要用于
<strong>模型选择（超参数调优）+
模型性能评估</strong>，避免“数据泄漏”导致的性能高估。</p>
<p>内层循环的作用：</p>
<ul>
<li><strong>针对不同超参数组合</strong>，依次进行 <span
class="math inline">\(M\)</span>-折交叉验证，计算平均验证性能。</li>
<li><strong>选出性能最好的超参数。</strong></li>
</ul>
<p>详见《嵌套交叉验证.md》</p>
</blockquote>
<blockquote>
<p>个人注：</p>
<p>引用前文8.2.2节：</p>
<p>对于给定的训练集 <span class="math inline">\(\{(x_1, y_1), \dots,
(x_N, y_N)\}\)</span>，我们引入矩阵表示法：样本矩阵 <span
class="math display">\[
X := [x_1, \dots, x_N]^\top \in \mathbb{R}^{N \times D}
\]</span> 以及标签向量 <span class="math display">\[
y := [y_1, \dots, y_N]^\top \in \mathbb{R}^N .
\]</span> 使用这种矩阵表示法，平均损失定义为： <span
class="math display">\[
R_{\text{emp}}(f, X, y) = \frac{1}{N} \sum_{n=1}^{N} \ell(y_n,
\hat{y}_n), \quad \text{其中 } \hat{y}_n = f(x_n, \theta). \tag{8.6}
\]</span> <strong>式 (8.6) 称为经验风险</strong>(empirical
risk)，它依赖三个参数：预测器 <span class="math inline">\(f\)</span>
和数据 <span class="math inline">\(X,
y\)</span>。这种基于经验风险的学习策略称为
<strong>经验风险最小化</strong>（Empirical Risk Minimization）。</p>
</blockquote>
<h4 id="贝叶斯模型选择"><strong>8.6.2 贝叶斯模型选择</strong></h4>
<p>模型选择有很多方法，本节会介绍其中的一些。一般来说，它们的共同目标是<strong>在模型复杂度与数据拟合程度之间做权衡</strong>。我们通常假设简单模型比复杂模型更不容易过拟合，因此模型选择的目标是找到一个<strong>足够简单但又能合理解释数据的模型</strong>。这个思想也被称为<strong>奥卡姆剃刀（Occam’s
razor）</strong>。</p>
<p><strong>备注</strong>：<u><em>如果把模型选择看作一个假设检验问题，那么我们就是在寻找与数据相一致的最简单的假设</em></u>（Murphy,
2012）。</p>
<p>有人可能会考虑在模型上加一个先验分布，偏向于简单模型。不过这并不是必须的：所谓“自动奥卡姆剃刀”已经自然地体现在贝叶斯概率的应用中（Smith
and Spiegelhalter, 1980; Jefferys and Berger, 1992; MacKay, 1992）。图
8.14（改编自 MacKay,
2003）给出了基本直觉，即为什么复杂、表达能力很强的模型反而可能对给定数据集
D 的建模来说不太合适。</p>
<p><img src="/img3/机器学习的数学基础Part2/F8.14.png" alt="F8.14" style="zoom:50%;" /></p>
<p>可以把横轴看作所有可能数据集 <span class="math inline">\(D\)</span>
的空间。如果我们关注给定数据 <span class="math inline">\(D\)</span>
时模型 <span class="math inline">\(M_i\)</span> 的后验概率 <span
class="math inline">\(p(M_i |
D)\)</span>，就可以使用贝叶斯定理。假设所有模型的先验 <span
class="math inline">\(p(M)\)</span>
是均匀分布，那么贝叶斯定理会奖励那些对实际出现的数据预测得更好的模型。这种给定模型
$M_i $对数据 <span class="math inline">\(D\)</span> 的预测概率 <span
class="math inline">\(p(D | M_i)\)</span>，称为模型 $M_i
$的<strong>证据（evidence）</strong>。</p>
<p>一个简单模型 $M_1 $只能预测很少一部分数据集，这用 <span
class="math inline">\(p(D | M_1)\)</span> 表示；而一个更强大的模型 <span
class="math inline">\(M_2\)</span>（比如拥有比 $M_1 <span
class="math inline">\(更多的自由参数）能够预测更广泛的数据集。但这同时意味着，\)</span>M_2$
对于某些区域 <span class="math inline">\(C\)</span> 的数据集预测得不如
<span class="math inline">\(M_1\)</span>
好。假设我们给两个模型分配了相同的先验概率，如果实际数据落在区域 <span
class="math inline">\(C\)</span>，那么较简单的模型 <span
class="math inline">\(M_1\)</span> 反而更可能是正确的模型。</p>
<p>在本章前面我们提到过，<strong>模型必须能够解释数据，即模型应当能够生成数据。</strong>如果模型是从数据中正确学习到的，那么我们希望它生成的数据应当与观测数据相似。为了实现这一点，把模型选择表述为一个<strong>分层推断问题（hierarchical
inference
problem）</strong>是有帮助的，这样我们就能够计算出模型的后验分布。</p>
<p><img src="/img3/机器学习的数学基础Part2/F8.15.png" alt="F8.15" style="zoom:67%;" /></p>
<p>我们考虑一个有限个模型的集合 <span class="math inline">\(M = \{M_1,
\dots, M_K\},\)</span> 其中每个模型 <span
class="math inline">\(M_k\)</span> 拥有参数 <span
class="math inline">\(\theta_k\)</span>。在贝叶斯模型选择（Bayesian
model selection）中，我们在模型集合上放置一个先验分布 <span
class="math inline">\(p(M)\)</span>。相应的生成过程（generative
process）允许我们从该模型中生成数据：</p>
<p><span class="math display">\[
M_k \sim p(M) \tag{8.40}
\]</span> 这一过程如图 8.15 所示。给定一个训练集 <span
class="math inline">\(D\)</span>，我们应用贝叶斯定理来计算模型的后验分布：
<span class="math display">\[
p(M_k \mid D) \propto p(M_k)\,p(D \mid M_k). \tag{8.43}
\]</span> 注意，这个后验分布不再依赖于模型参数 <span
class="math inline">\(\theta_k\)</span>，因为在贝叶斯框架中它们已经被积分掉了：
<span class="math display">\[
p(D \mid M_k) = \int p(D \mid \theta_k)\,p(\theta_k \mid M_k)\,
d\theta_k, \tag{8.44}
\]</span> 其中 <span class="math inline">\(p(\theta_k \mid M_k)\)</span>
是模型 <span class="math inline">\(M_k\)</span> 的参数 <span
class="math inline">\(\theta_k\)</span> 的先验分布。式 (8.44) 被称为
<strong>模型证据（model evidence）</strong> 或
<strong>边际似然（marginal likelihood）</strong>。根据式 (8.43)
的后验分布，我们可以确定最大后验（MAP）估计：</p>
<p><span class="math display">\[
M^* = \arg\max_{M_k} p(M_k \mid D). \tag{8.45}
\]</span> 如果先验是均匀的，即 <span class="math inline">\(p(M_k) =
\tfrac{1}{K}\)</span>，也就是说每个模型都有相同的（先验）概率，那么模型的
MAP 估计就等价于选择 使模型证据 (8.44) 最大的模型。</p>
<p><strong>备注（似然与边际似然 ）</strong>Likelihood and Marginal
Likelihood 似然与边际似然（证据）之间存在一些重要区别：</p>
<ul>
<li>似然容易过拟合，而边际似然通常不会，因为模型参数已被边际化（即我们不再需要去拟合参数本身）。</li>
<li>此外，<strong>边际似然会自动体现出模型复杂度与数据拟合之间的权衡（奥卡姆剃刀原则，Occam’s
razor）。</strong></li>
</ul>
<h4 id="贝叶斯因子用于模型比较">8.6.3 贝叶斯因子用于模型比较</h4>
<p>考虑在给定数据集 <span class="math inline">\(D\)</span>
的情况下，比较两个概率模型 <span class="math inline">\(M_1\)</span> 和
<span class="math inline">\(M_2\)</span> 的问题。如果我们计算后验概率
<span class="math inline">\(p(M_1 \mid D)\)</span> 和 <span
class="math inline">\(p(M_2 \mid
D)\)</span>，那么我们可以得到它们的比值：</p>
<p><span class="math display">\[
\begin{equation}
\underbrace{\frac{p(M_{1}\mid \mathcal{D})}{p(M_{2}\mid
\mathcal{D})}}_{\text{posterior odds}}
=
\frac{\frac{p(\mathcal{D}\mid
M_{1})p(M_{1})}{p(\mathcal{D})}}{\frac{p(\mathcal{D}\mid
M_{2})p(M_{2})}{p(\mathcal{D})}}
=
\underbrace{\frac{p(M_{1})}{p(M_{2})}}_{\text{prior odds}}
\underbrace{\frac{p(\mathcal{D}\mid M_{1})}{p(\mathcal{D}\mid
M_{2})}}_{\text{Bayes factor}} .
\tag{8.46}
\end{equation}
\]</span></p>
<p>后验比（posterior odds）就是后验概率的比值。在式 (8.46)
的右边，第一个分式称为
<strong>先验比</strong>，它衡量的是我们在观察数据之前对 <span
class="math inline">\(M_1\)</span> 相较于 <span
class="math inline">\(M_2\)</span>
的偏好。第二个分式，即边际似然（marginal likelihood）的比值，被称为
<strong>贝叶斯因子</strong>，它衡量的是在两个模型下，数据 <span
class="math inline">\(D\)</span> 的可预测程度差异。</p>
<p><strong>备注（Jeffreys–Lindley 悖论）</strong> Jeffreys–Lindley
悖论指出：
“贝叶斯因子总是偏向于更简单的模型，因为在一个复杂模型下，若采用弥散先验（diffuse
prior），数据的概率会非常小。”（Murphy,
2012）这里的弥散先验指的是一种没有明显偏好、即对许多模型都先验上认为合理的先验分布。</p>
<p>如果我们在模型之间采用均匀先验，那么式 (8.46) 中的先验比为 <span
class="math inline">\(1\)</span>，即： <span class="math display">\[
\text{后验比} \;=\; \frac{p(D \mid M_1)}{p(D \mid M_2)} \tag{8.47}
\]</span> 在这种情况下，贝叶斯因子就是边际似然的比值。如果贝叶斯因子大于
1，我们选择模型 <span class="math inline">\(M_1\)</span>；否则选择模型
<span
class="math inline">\(M_2\)</span>。与频率学派统计方法类似，人们也提出了一些关于贝叶斯因子大小的经验性指南，用于判断结果是否“显著”（Jeffreys,
1961）。</p>
<p><strong>备注（计算边际似然）</strong>
边际似然在模型选择中起着重要作用：我们需要它来计算贝叶斯因子
(8.46)，以及模型的后验分布 (8.43)。不幸的是，边际似然的计算涉及积分
(8.44)，而这个积分通常在解析上不可解。因此我们必须借助近似方法，例如：</p>
<ul>
<li>数值积分（Stoer and Burlirsch, 2002），</li>
<li>基于 Monte Carlo 的随机近似（Murphy, 2012），</li>
<li>或者贝叶斯 Monte Carlo 技术（O’Hagan, 1991; Rasmussen and
Ghahramani, 2003）。</li>
</ul>
<p>不过，在一些特殊情况下，这个积分是可以解析解出的。在 第 6.6.1 节
中，我们讨论过共轭模型。如果选择一个共轭先验 <span
class="math inline">\(p(\theta)\)</span>，则可以直接得到边际似然的闭式解。在
第 9 章 中，我们将在 <strong>线性回归</strong> 的背景下展示这一点。</p>
<p>我们在本章中已经对机器学习的基本概念进行了简要介绍。在本书接下来的部分中，我们将看到第
8.2、8.3 和 8.4
节中三种不同类型的学习方法是如何应用于机器学习的四大支柱（回归、降维、密度估计和分类
(regression, dimensionality reduction, density estimation, and
classification）的。</p>
<h4 id="延伸阅读-4">8.6.4 延伸阅读</h4>
<p>我们在本节开头提到，<strong>高层次的建模选择会影响模型的性能。例子包括</strong>：</p>
<ul>
<li>回归问题中多项式的次数</li>
<li>混合模型中的成分数目</li>
<li>（深度）神经网络的网络结构</li>
<li>支持向量机中的核函数类型</li>
<li>主成分分析（PCA）中潜在空间的维度</li>
<li>优化算法中的学习率（或学习率调度）</li>
</ul>
<p>Rasmussen 和
Ghahramani（2001）表明，自动奥卡姆剃刀并不一定惩罚模型中参数的数量，而是作用于函数的复杂性。他们还表明，这种自动奥卡姆剃刀同样适用于具有大量参数的贝叶斯非参数模型，例如高斯过程。</p>
<p><strong>如果我们<em><u>专注于极大似然估计</u></em>，则存在许多用于模型选择的启发式方法来避免过拟合。这些方法被称为信息准则（information
criteria），我们通常选择使其值最大的模型。</strong></p>
<p><strong>赤池信息准则（Akaike Information Criterion,
AIC）</strong>（Akaike, 1974）： <span class="math display">\[
\log p(x|\theta) - M \quad (8.48)
\]</span>
它通过增加一个惩罚项来修正极大似然估计的偏差，以补偿复杂模型（具有大量参数）所带来的过拟合问题。这里
<span class="math inline">\(M\)</span> 表示模型参数的个数。AIC
用于估计给定模型所丢失的相对信息量。</p>
<p><strong>贝叶斯信息准则（Bayesian Information Criterion,
BIC）</strong>（Schwarz, 1978）： <span class="math display">\[
\log p(x) = \log \int p(x|\theta)p(\theta)\, d\theta \approx \log
p(x|\theta) - \tfrac{1}{2} M \log N \quad (8.49)
\]</span> 它可用于指数族分布。在这里，<span
class="math inline">\(N\)</span> 是数据点的数量，<span
class="math inline">\(M\)</span> 是参数的数量。与 AIC 相比，BIC
对模型复杂度的惩罚更为严格。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag"># 数学</a>
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
              <a href="/tags/%E7%BB%9F%E8%AE%A1/" rel="tag"># 统计</a>
              <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag"># 深度学习</a>
              <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag"># 机器学习</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/09/09/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E3%80%8B%E7%AC%AC12%E7%AB%A0%22%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%88%86%E7%B1%BB%22/" rel="prev" title="《机器学习的数学基础》第12章"支持向量机分类"">
                  <i class="fa fa-chevron-left"></i> 《机器学习的数学基础》第12章"支持向量机分类"
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/09/09/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E3%80%8B%E7%AC%AC10%E7%AB%A0%22%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%E7%9A%84%E9%99%8D%E7%BB%B4%22/" rel="next" title="《机器学习的数学基础》第10章"主成分分析的降维"">
                  《机器学习的数学基础》第10章"主成分分析的降维" <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rayman.hung</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
