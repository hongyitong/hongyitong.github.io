<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hongyitong.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="《Practical Statistics for Data Scientists》书籍英文版 《面向数据科学家的实用统计学》中文版书籍 第 4 章 回归与预测 在统计学中，也许最常见的目标就是回答这样的问题：“变量 X（或者更常见地，X₁, …, Xₚ）是否与变量 Y 有关联？如果有，这种关系是什么，我们能否利用它来预测 Y？” 在预测领域——特别是基于其他“预测变量”的值来预测一个结果（目标）">
<meta property="og:type" content="article">
<meta property="og:title" content="第4章 回归与预测">
<meta property="og:url" content="http://hongyitong.github.io/2025/09/25/%E7%AC%AC4%E7%AB%A0%20%E5%9B%9E%E5%BD%92%E4%B8%8E%E9%A2%84%E6%B5%8B/index.html">
<meta property="og:site_name" content="墨语浮生">
<meta property="og:description" content="《Practical Statistics for Data Scientists》书籍英文版 《面向数据科学家的实用统计学》中文版书籍 第 4 章 回归与预测 在统计学中，也许最常见的目标就是回答这样的问题：“变量 X（或者更常见地，X₁, …, Xₚ）是否与变量 Y 有关联？如果有，这种关系是什么，我们能否利用它来预测 Y？” 在预测领域——特别是基于其他“预测变量”的值来预测一个结果（目标）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%9A%84%E5%AE%9E%E7%94%A8%E7%BB%9F%E8%AE%A1%E5%AD%A6/F4.1.png">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%9A%84%E5%AE%9E%E7%94%A8%E7%BB%9F%E8%AE%A1%E5%AD%A6/F4.2.png">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%9A%84%E5%AE%9E%E7%94%A8%E7%BB%9F%E8%AE%A1%E5%AD%A6/F4.3.png">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%9A%84%E5%AE%9E%E7%94%A8%E7%BB%9F%E8%AE%A1%E5%AD%A6/T4.1.png">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%9A%84%E5%AE%9E%E7%94%A8%E7%BB%9F%E8%AE%A1%E5%AD%A6/F4.4.png">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%9A%84%E5%AE%9E%E7%94%A8%E7%BB%9F%E8%AE%A1%E5%AD%A6/F4.5.png">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%9A%84%E5%AE%9E%E7%94%A8%E7%BB%9F%E8%AE%A1%E5%AD%A6/F4.6.png">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%9A%84%E5%AE%9E%E7%94%A8%E7%BB%9F%E8%AE%A1%E5%AD%A6/T4.2.png">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%9A%84%E5%AE%9E%E7%94%A8%E7%BB%9F%E8%AE%A1%E5%AD%A6/F4.7.png">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%9A%84%E5%AE%9E%E7%94%A8%E7%BB%9F%E8%AE%A1%E5%AD%A6/F4.8.png">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%9A%84%E5%AE%9E%E7%94%A8%E7%BB%9F%E8%AE%A1%E5%AD%A6/F4.9.png">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%9A%84%E5%AE%9E%E7%94%A8%E7%BB%9F%E8%AE%A1%E5%AD%A6/F4.10.png">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%9A%84%E5%AE%9E%E7%94%A8%E7%BB%9F%E8%AE%A1%E5%AD%A6/F4.11.png">
<meta property="og:image" content="http://hongyitong.github.io/img3/%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%9A%84%E5%AE%9E%E7%94%A8%E7%BB%9F%E8%AE%A1%E5%AD%A6/F4.12.png">
<meta property="article:published_time" content="2025-09-24T16:00:00.000Z">
<meta property="article:modified_time" content="2025-11-07T02:20:06.441Z">
<meta property="article:author" content="Rayman.hung">
<meta property="article:tag" content="统计">
<meta property="article:tag" content="深度学习">
<meta property="article:tag" content="AI">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="机器学习">
<meta property="article:tag" content="数据科学">
<meta property="article:tag" content="R">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hongyitong.github.io/img3/%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%9A%84%E5%AE%9E%E7%94%A8%E7%BB%9F%E8%AE%A1%E5%AD%A6/F4.1.png">


<link rel="canonical" href="http://hongyitong.github.io/2025/09/25/%E7%AC%AC4%E7%AB%A0%20%E5%9B%9E%E5%BD%92%E4%B8%8E%E9%A2%84%E6%B5%8B/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://hongyitong.github.io/2025/09/25/%E7%AC%AC4%E7%AB%A0%20%E5%9B%9E%E5%BD%92%E4%B8%8E%E9%A2%84%E6%B5%8B/","path":"2025/09/25/第4章 回归与预测/","title":"第4章 回归与预测"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>第4章 回归与预测 | 墨语浮生</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZXGEJDXQ33"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-ZXGEJDXQ33","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">墨语浮生</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Rayman</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section">首页</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section">分类</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section">关于</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section">归档</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section">标签</a></li><li class="menu-item menu-item-commonweal"><a href="/404.html" rel="section">公益 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC-4-%E7%AB%A0-%E5%9B%9E%E5%BD%92%E4%B8%8E%E9%A2%84%E6%B5%8B"><span class="nav-text">第 4 章 回归与预测</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92"><span class="nav-text">简单线性回归</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E5%BD%92%E6%96%B9%E7%A8%8B"><span class="nav-text">回归方程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%9F%E5%90%88%E5%80%BC%E4%B8%8E%E6%AE%8B%E5%B7%AE"><span class="nav-text">拟合值与残差</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95"><span class="nav-text">最小二乘法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%84%E6%B5%8B%E4%B8%8E%E8%A7%A3%E9%87%8A%E7%94%BB%E5%83%8F%E5%88%86%E6%9E%90"><span class="nav-text">预测与解释（画像分析）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92"><span class="nav-text">多元线性回归</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-text">示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%84%E4%BC%B0%E6%A8%A1%E5%9E%8B"><span class="nav-text">评估模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81"><span class="nav-text">交叉验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9%E4%B8%8E%E9%80%90%E6%AD%A5%E5%9B%9E%E5%BD%92"><span class="nav-text">模型选择与逐步回归</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E6%9D%83%E5%9B%9E%E5%BD%92"><span class="nav-text">加权回归</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9B%9E%E5%BD%92%E8%BF%9B%E8%A1%8C%E9%A2%84%E6%B5%8B"><span class="nav-text">使用回归进行预测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%96%E6%8E%A8%E7%9A%84%E5%8D%B1%E9%99%A9%E6%80%A7"><span class="nav-text">外推的危险性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%AE%E4%BF%A1%E5%8C%BA%E9%97%B4%E4%B8%8E%E9%A2%84%E6%B5%8B%E5%8C%BA%E9%97%B4"><span class="nav-text">置信区间与预测区间</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E5%BD%92%E4%B8%AD%E7%9A%84%E5%9B%A0%E5%AD%90%E5%8F%98%E9%87%8F"><span class="nav-text">回归中的因子变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%8F%98%E9%87%8F%E8%A1%A8%E7%A4%BA"><span class="nav-text">虚拟变量表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B7%E6%9C%89%E8%AE%B8%E5%A4%9A%E6%B0%B4%E5%B9%B3%E7%9A%84%E5%9B%A0%E5%AD%90%E5%8F%98%E9%87%8F"><span class="nav-text">具有许多水平的因子变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E5%9B%A0%E5%AD%90%E5%8F%98%E9%87%8F"><span class="nav-text">有序因子变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E5%9B%9E%E5%BD%92%E6%96%B9%E7%A8%8B"><span class="nav-text">解释回归方程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%84%E6%B5%8B%E5%8F%98%E9%87%8F"><span class="nav-text">相关预测变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E5%85%B1%E7%BA%BF%E6%80%A7"><span class="nav-text">多重共线性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B7%E6%9D%82%E5%8F%98%E9%87%8F"><span class="nav-text">混杂变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A4%E4%BA%92%E4%BD%9C%E7%94%A8%E4%B8%8E%E4%B8%BB%E6%95%88%E5%BA%94"><span class="nav-text">交互作用与主效应</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E5%BD%92%E8%AF%8A%E6%96%AD"><span class="nav-text">回归诊断</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A6%BB%E7%BE%A4%E5%80%BC"><span class="nav-text">离群值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%B1%E5%93%8D%E5%8A%9B%E5%80%BC"><span class="nav-text">影响力值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%96%B9%E5%B7%AE%E6%80%A7%E9%9D%9E%E6%AD%A3%E6%80%81%E6%80%A7%E4%B8%8E%E7%9B%B8%E5%85%B3%E8%AF%AF%E5%B7%AE"><span class="nav-text">异方差性、非正态性与相关误差</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%8F%E6%AE%8B%E5%B7%AE%E5%9B%BE%E4%B8%8E%E9%9D%9E%E7%BA%BF%E6%80%A7"><span class="nav-text">偏残差图与非线性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E6%A0%B7%E6%9D%A1%E5%9B%9E%E5%BD%92"><span class="nav-text">多项式与样条回归</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9B%9E%E5%BD%92"><span class="nav-text">多项式回归</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E6%9D%A1%E5%9B%9E%E5%BD%92"><span class="nav-text">样条回归</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%BF%E4%B9%89%E5%8A%A0%E6%80%A7%E6%A8%A1%E5%9E%8B"><span class="nav-text">广义加性模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Rayman.hung</p>
  <div class="site-description" itemprop="description">技术分享、读书心得、心情记录</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives">
          <span class="site-state-item-count">168</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags">
        <span class="site-state-item-count">328</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hongyitong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hongyitong" rel="noopener" target="_blank">GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hongyitong.github.io/2025/09/25/%E7%AC%AC4%E7%AB%A0%20%E5%9B%9E%E5%BD%92%E4%B8%8E%E9%A2%84%E6%B5%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rayman.hung">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="墨语浮生">
      <meta itemprop="description" content="技术分享、读书心得、心情记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="第4章 回归与预测 | 墨语浮生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          第4章 回归与预测
        </h1>

        </h1>
          
        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-25 00:00:00" itemprop="dateCreated datePublished" datetime="2025-09-25T00:00:00+08:00">2025-09-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BF%BB%E8%AF%91/" itemprop="url" rel="index"><span itemprop="name">翻译</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><a
href="/img3/面向数据科学家的实用统计学/Practical-Statistics-for-Data-Scientists.pdf">《Practical
Statistics for Data Scientists》书籍英文版</a><br />
<a
href="/img3/面向数据科学家的实用统计学/面向数据科学家的实用统计学.pdf">《面向数据科学家的实用统计学》中文版书籍</a></p>
<h2 id="第-4-章-回归与预测">第 4 章 回归与预测</h2>
<p>在统计学中，也许最常见的目标就是回答这样的问题：“变量
X（或者更常见地，X₁, …, Xₚ）是否与变量 Y
有关联？如果有，这种关系是什么，我们能否利用它来预测 Y？”</p>
<p>在预测领域——特别是基于其他“预测变量”的值来预测一个结果（目标）变量——<strong>统计学与数据科学</strong>的联系最为紧密。这一过程是在结果已知的数据上训练模型，以便随后将其应用于结果未知的数据，称为<strong>监督学习</strong>。数据科学与统计学的另一个重要交叉领域是<strong>异常检测</strong>：最初用于数据分析和改进回归模型的回归诊断方法，也可用来检测异常记录。</p>
<span id="more"></span>
<h3 id="简单线性回归">简单线性回归</h3>
<p>简单线性回归提供了一个描述两个变量大小之间关系的模型。例如，随着 X
增大，Y 也增大；或者随着 X 增大，Y
减小。相关系数是衡量两个变量如何相关的另一种方式（见第 30
页“相关”一节）。不同的是，相关系数衡量的是两个变量之间联系的强度，而回归则量化了这种关系的具体形式。</p>
<p><strong>简单线性回归的关键术语</strong></p>
<p><strong>响应变量（Response）</strong> 我们试图预测的变量。
同义词：因变量、Y 变量、目标、结果</p>
<p>​ dependent variable, Y variable, target, outcome</p>
<p><strong>自变量（Independent variable）</strong>
用于预测响应变量的变量。 同义词：X 变量、特征、属性、预测变量</p>
<p>​ X variable, feature, attribute, predictor</p>
<p><strong>记录（Record）</strong>
某个具体个体或案例的预测变量与结果变量值构成的向量。
同义词：行、案例、实例、样本</p>
<p><strong>截距（Intercept）</strong> 回归直线的截距，即当 X = 0
时预测的值。 同义词：b₀、β₀</p>
<p><strong>回归系数（Regression coefficient）</strong> 回归直线的斜率。
同义词：斜率、b₁、β₁、参数估计、权重</p>
<p><strong>拟合值（Fitted values）</strong> 从回归直线得到的 Ŷᵢ
的估计值。 同义词：预测值</p>
<p><strong>残差（Residuals）</strong> 观测值与拟合值之间的差异。
同义词：误差</p>
<p>​ errors</p>
<p><strong>最小二乘法（Least squares）</strong>
通过最小化残差平方和来拟合回归的方法。 同义词：普通最小二乘、OLS</p>
<h4 id="回归方程">回归方程</h4>
<p>The Regression Equation</p>
<p>简单线性回归估计当 X 发生一定变化时，Y 会改变多少。在相关系数中，变量
X 和 Y
是可以互换的；而在回归分析中，我们试图利用线性关系（即一条直线）由 X
预测 Y 变量： <span class="math display">\[
Y = b_0 + b_1X
\]</span></p>
<p>我们读作：“Y 等于 b₁ 乘以 X，再加上一个常数 b₀”。符号
<strong>b₀</strong> 称为截距（或常数），符号 <strong>b₁</strong> 称为 X
的斜率。在 R
的输出中，两者都显示为系数，不过在一般用法中，“系数”这一术语通常只指
b₁。Y
变量称为<strong>响应变量</strong>或<strong>因变量</strong>，因为它依赖于
X；X
变量称为<strong>预测变量</strong>或<strong>自变量</strong>。机器学习领域倾向于用其他术语，把
Y 称为“目标（target）”，把 X 称为“特征向量（feature
vector）”。在本书中，我们将“预测变量（predictor）”和“特征（feature）”两个词交替使用。</p>
<p><img src="/img3/面向数据科学家的实用统计学/F4.1.png" alt="F4.1" style="zoom:33%;" /></p>
<p>请看图 4-1
中的散点图，显示工人接触棉尘的年数（Exposure）与肺活量指标（PEFR
或“呼气峰流速”）之间的关系。PEFR 与 Exposure
的关系如何？仅从图上很难判断。</p>
<p>简单线性回归试图找到一条“最佳”的直线，用来预测响应变量 PEFR
作为预测变量 Exposure 的函数：</p>
<p><span class="math display">\[
\text{PEFR} = b_0 + b_1\text{Exposure}
\]</span></p>
<p>在 R 中可以用 <strong>lm</strong> 函数拟合线性回归模型：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model <span class="operator">&lt;-</span> lm<span class="punctuation">(</span>PEFR <span class="operator">~</span> Exposure<span class="punctuation">,</span> data<span class="operator">=</span>lung<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>lm 表示 “linear model”，波浪号 <code>~</code> 表示“由 Exposure 预测
PEFR”。在这种模型定义下，截距会自动包含并拟合。如果想排除截距，需要这样写：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PEFR <span class="operator">~</span> Exposure <span class="operator">-</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>打印模型对象得到如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Call:</span><br><span class="line">lm(formula = PEFR ~ Exposure, data = lung)</span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">(Intercept)   Exposure</span><br><span class="line">   424.583     -4.185</span><br></pre></td></tr></table></figure>
<p>其中截距 <strong>b₀ = 424.583</strong>，可以解释为“工人接触棉尘年数为
0 时预测的 PEFR”。回归系数 <strong>b₁ = -4.185</strong>
可以解释为：“工人每多接触棉尘一年，PEFR 测量值平均减少 4.185”。</p>
<p>在 Python 中，可以使用 scikit-learn 包的
<strong>LinearRegression</strong>。（statsmodels 包也有一个与 R
类似的线性回归实现 sm.OLS，我们将在本章后面使用它）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">predictors = [<span class="string">&#x27;Exposure&#x27;</span>]</span><br><span class="line">outcome = <span class="string">&#x27;PEFR&#x27;</span></span><br><span class="line">model = LinearRegression()</span><br><span class="line">model.fit(lung[predictors], lung[outcome])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Intercept: <span class="subst">&#123;model.intercept_:<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Coefficient Exposure: <span class="subst">&#123;model.coef_[<span class="number">0</span>]:<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>该模型得到的回归直线如图 4-2 所示。</p>
<p><img src="/img3/面向数据科学家的实用统计学/F4.2.png" alt="F4.2" style="zoom:33%;" /></p>
<h4 id="拟合值与残差">拟合值与残差</h4>
<p>Fitted Values and Residuals</p>
<p>回归分析中的重要概念是<strong>拟合值</strong>（预测值the
predictions）和<strong>残差</strong>（预测误差 prediction
errors）。一般情况下，数据不会完全落在一条直线上，所以回归方程应包含一个显式的误差项
<span class="math inline">\(e_i\)</span>：</p>
<p><span class="math display">\[
Y_i = b_0 + b_1X_i + e_i
\]</span></p>
<p><strong>拟合值</strong>（也称<strong>预测值</strong>）通常记作 <span
class="math inline">\(\hat{Y}_i\)</span>（Y-hat），其表达式为：</p>
<p><span class="math display">\[
\hat{Y}_i = b_0 + b_1X_i
\]</span></p>
<p>这里的 <span class="math inline">\(b_0\)</span> 和 <span
class="math inline">\(b_1\)</span> 表示系数是估计值，而不是已知值。</p>
<blockquote>
<p><strong>知识点：</strong></p>
<p>“帽子”符号（hat
notation）用来区分<strong>估计值</strong>与<strong>真实值</strong>。因此，符号
<span class="math inline">\(\hat{b}\)</span>（“b-hat”）是未知参数 <span
class="math inline">\(b\)</span>
的估计值。统计学家之所以要区分估计值和真实值，是因为<strong>估计值有不确定性，而真实值是固定的</strong>。</p>
</blockquote>
<p>我们通过原始数据减去预测值来计算残差 <span
class="math inline">\(e_i\)</span>：</p>
<p><span class="math display">\[
e_i = Y_i - \hat{Y}_i
\]</span></p>
<p>在 R 中，可以用 <strong>predict</strong> 和
<strong>residuals</strong> 函数获得拟合值和残差：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fitted <span class="operator">&lt;-</span> predict<span class="punctuation">(</span>model<span class="punctuation">)</span></span><br><span class="line">resid <span class="operator">&lt;-</span> residuals<span class="punctuation">(</span>model<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>在 scikit-learn 的 <strong>LinearRegression</strong> 模型中，可以用
<strong>predict</strong> 方法在训练数据上获得拟合值，再计算残差。这是
scikit-learn 中所有模型的通用模式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fitted = model.predict(lung[predictors])</span><br><span class="line">residuals = lung[outcome] - fitted</span><br></pre></td></tr></table></figure>
<p>图 4-3
展示了肺活量数据回归直线的残差。残差就是从数据点到回归直线的垂直虚线的长度。</p>
<p><img src="/img3/面向数据科学家的实用统计学/F4.3.png" alt="F4.3" style="zoom:50%;" /></p>
<h4 id="最小二乘法">最小二乘法</h4>
<p>Least Squares</p>
<p>那么模型是如何拟合数据的？当关系很明显时，你可以想象手工拟合一条直线。实际上，<strong>回归直线是通过最小化残差平方和（RSS,
residual sum of squares）来估计的</strong>：</p>
<p><span class="math display">\[
\text{RSS}=\sum_{i=1}^{n}(Y_i - \hat{Y}_i)^2
=\sum_{i=1}^{n}(Y_i - b_0 - b_1X_i)^2
\]</span></p>
<p><span class="math inline">\(b_0\)</span> 和 <span
class="math inline">\(b_1\)</span> 的估计值是使 RSS 最小的数值。</p>
<p>最小化残差平方和的方法称为<strong>最小二乘回归</strong>（least
squares regression），或<strong>普通最小二乘回归</strong>（ordinary
least squares, OLS）。这种方法常被归功于德国数学家高斯（Carl Friedrich
Gauss），但实际上是由法国数学家勒让德（Adrien-Marie Legendre）在 1805
年首次发表的。最小二乘回归可以通过任何标准统计软件快速、方便地计算。</p>
<p>从历史上看，计算便利性是最小二乘法在回归中广泛应用的原因之一。在大数据时代，计算速度仍然是重要因素。<strong>最小二乘法对异常值敏感</strong>（就像均值一样，见第
10
页的“中位数与稳健估计”），不过这通常只在小型或中等规模数据集里才是个显著问题。有关回归中异常值的讨论见第
177 页“异常值”。</p>
<blockquote>
<p><strong>通用注解</strong></p>
<p>回归术语<strong>：当分析师和研究人员单独使用“回归”这个词时，通常指的是</strong>线性回归<strong>，重点是建立一个线性模型来解释预测变量与数值型结果变量之间的关系。在正式的统计学意义上，</strong>回归还包括非线性模型<strong>，即预测变量与结果变量之间存在某种函数关系的模型。在机器学习领域，“回归”这个词有时也被宽泛地用来指任何</strong>输出连续数值型预测<strong>的模型（而相对于</strong>分类**方法，分类预测的是二元或类别型结果）。</p>
</blockquote>
<h4 id="预测与解释画像分析"><strong>预测与解释（画像分析）</strong></h4>
<p>Prediction Versus Explanation (Profiling)</p>
<p>从<strong>历史上</strong>看，回归分析的主要用途是揭示预测变量与结果变量之间的线性关系。<strong>目标是理解这种关系，并用拟合回归的数据来解释它</strong>。在这种情况下，主要关注的是回归方程中估计的斜率
<span class="math inline">\(b\)</span>。经济学家想知道消费者支出与 GDP
增长之间的关系；公共卫生官员可能想了解一项公共宣传活动是否在促进安全性行为方面有效。在这些例子中，重点不是预测单个案例，而是理解变量之间的总体关系。</p>
<p>随着<strong>大数据</strong>的出现，回归被广泛<strong>用于为新数据预测个体结果（即建立预测模型），而不是解释手头的数据</strong>。在这种情况下，主要关注的是拟合值
<span
class="math inline">\(\hat{Y}\)</span>。在市场营销中，回归可用于预测广告投放规模变化带来的收入变化；大学利用回归预测学生的
GPA 与其 SAT 分数之间的关系。</p>
<p>一个拟合良好的回归模型表明，当 <span class="math inline">\(X\)</span>
发生变化时，<span class="math inline">\(Y\)</span>
也会随之变化。然而，<strong>仅凭回归方程并不能证明因果方向</strong>。因果推论必须基于对关系更广泛的理解。例如，回归方程可能显示网页广告点击数与转化数之间存在显著关系。得出“点击广告导致销售”而不是“销售导致点击”的结论，<strong>是基于我们对营销过程的知识，而非回归方程本身。</strong></p>
<p><strong>关键要点</strong></p>
<ul>
<li>回归方程将响应变量 <span class="math inline">\(Y\)</span> 与预测变量
<span class="math inline">\(X\)</span> 的关系建模为一条直线。</li>
<li>回归模型产生拟合值和残差——即响应的预测值以及预测误差。</li>
<li>回归模型通常通过最小二乘法来拟合。</li>
<li>回归既可用于预测，也可用于解释。</li>
</ul>
<h3 id="多元线性回归"><strong>多元线性回归</strong></h3>
<p>Multiple Linear Regression</p>
<p>当有多个预测变量时，方程可以扩展为： <span class="math display">\[
Y = b_0 + b_1 X_1 + b_2 X_2 + \dots + b_p X_p + e
\]</span></p>
<p>此时不再是一条直线，而是一个线性模型——每个系数与其变量（特征）之间的关系是线性的。</p>
<p><strong>多元线性回归关键术语</strong></p>
<ul>
<li><p><strong>均方根误差（Root mean squared error, RMSE）</strong>
回归平均平方误差的平方根（这是比较回归模型最广泛使用的指标）。</p></li>
<li><p><strong>残差标准误（Residual standard error, RSE）</strong>
与均方根误差相同，但对自由度进行了调整。</p></li>
<li><p><strong>R 平方（R-squared, <span
class="math inline">\(R^2\)</span>）</strong> 模型解释的方差比例，从 0
到 1。 同义词：决定系数（coefficient of determination）。</p></li>
<li><p><strong>t 统计量（t-statistic）</strong>
某个预测变量系数除以其标准误差，提供衡量模型中变量重要性的指标（参见第
110 页 “t 检验”）。</p></li>
<li><p><strong>加权回归（Weighted regression）</strong>
对不同记录赋予不同权重的回归。</p></li>
</ul>
<p>简单线性回归中的其他概念（如最小二乘拟合、拟合值和残差的定义）都可以推广到多元线性回归。例如，拟合值为：</p>
<p><span class="math display">\[
\hat{Y}_i = b_0 + b_1 X_{1,i} + b_2 X_{2,i} + \dots + b_p X_{p,i}
\]</span></p>
<h4 id="示例"><strong>示例</strong></h4>
<p>King County房屋数据</p>
<p>多元线性回归的一个示例是估计房屋价值。县评估员需要估算房屋的价值以评税；房地产专业人士和购房者会参考
Zillow
等流行网站来判断一个公平价格。下面是来自美国华盛顿州金县（西雅图）的房屋数据（<code>house</code>
数据框）的一些行：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head<span class="punctuation">(</span>house<span class="punctuation">[</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;AdjSalePrice&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;SqFtTotLiving&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;SqFtLot&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;Bathrooms&#x27;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&#x27;Bedrooms&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;BldgGrade&#x27;</span><span class="punctuation">)</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>数据来源：本地数据框 [6 x 6]</p>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 20%" />
<col style="width: 13%" />
<col style="width: 15%" />
<col style="width: 14%" />
<col style="width: 15%" />
</colgroup>
<thead>
<tr class="header">
<th>AdjSalePrice (int)</th>
<th>SqFtTotLiving (dbl)</th>
<th>SqFtLot (int)</th>
<th>Bathrooms (int)</th>
<th>Bedrooms (dbl)</th>
<th>BldgGrade (int)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>300805</td>
<td>2400</td>
<td>9373</td>
<td>3.00</td>
<td>6</td>
</tr>
<tr class="even">
<td>2</td>
<td>1076162</td>
<td>3764</td>
<td>20156</td>
<td>3.75</td>
<td>4</td>
</tr>
<tr class="odd">
<td>3</td>
<td>761805</td>
<td>2060</td>
<td>26036</td>
<td>1.75</td>
<td>4</td>
</tr>
<tr class="even">
<td>4</td>
<td>442065</td>
<td>3200</td>
<td>8618</td>
<td>3.75</td>
<td>5</td>
</tr>
<tr class="odd">
<td>5</td>
<td>297065</td>
<td>1720</td>
<td>8620</td>
<td>1.75</td>
<td>4</td>
</tr>
<tr class="even">
<td>6</td>
<td>411781</td>
<td>930</td>
<td>1012</td>
<td>1.50</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>在 pandas 中，<code>head</code> 方法同样列出前几行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subset = [<span class="string">&#x27;AdjSalePrice&#x27;</span>, <span class="string">&#x27;SqFtTotLiving&#x27;</span>, <span class="string">&#x27;SqFtLot&#x27;</span>, <span class="string">&#x27;Bathrooms&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Bedrooms&#x27;</span>, <span class="string">&#x27;BldgGrade&#x27;</span>]</span><br><span class="line">house[subset].head()</span><br></pre></td></tr></table></figure>
<p>我们的目标是用其它变量预测销售价格。R 语言的 <code>lm</code>
函数通过在公式右边加入更多变量就可以处理多元回归；参数
<code>na.action=na.omit</code> 表示模型会丢弃包含缺失值的记录：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">house_lm <span class="operator">&lt;-</span> lm<span class="punctuation">(</span>AdjSalePrice <span class="operator">~</span> SqFtTotLiving <span class="operator">+</span> SqFtLot <span class="operator">+</span> Bathrooms <span class="operator">+</span></span><br><span class="line">Bedrooms <span class="operator">+</span> BldgGrade<span class="punctuation">,</span></span><br><span class="line">data<span class="operator">=</span>house<span class="punctuation">,</span> na.action<span class="operator">=</span>na.omit<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>scikit-learn 的 <code>LinearRegression</code>
也可以用于多元线性回归：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">predictors = [<span class="string">&#x27;SqFtTotLiving&#x27;</span>, <span class="string">&#x27;SqFtLot&#x27;</span>, <span class="string">&#x27;Bathrooms&#x27;</span>, <span class="string">&#x27;Bedrooms&#x27;</span>, <span class="string">&#x27;BldgGrade&#x27;</span>]</span><br><span class="line">outcome = <span class="string">&#x27;AdjSalePrice&#x27;</span></span><br><span class="line">house_lm = LinearRegression()</span><br><span class="line">house_lm.fit(house[predictors], house[outcome])</span><br></pre></td></tr></table></figure>
<p>在 R 中打印 <code>house_lm</code> 对象会产生以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Call:</span><br><span class="line">lm(formula = AdjSalePrice ~ SqFtTotLiving + SqFtLot + Bathrooms +</span><br><span class="line">Bedrooms + BldgGrade, data = house, na.action = na.omit)</span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">(Intercept) SqFtTotLiving SqFtLot Bathrooms</span><br><span class="line">-5.219e+05 2.288e+02 -6.047e-02 -1.944e+04</span><br><span class="line">Bedrooms BldgGrade</span><br><span class="line">-4.777e+04 1.061e+05</span><br></pre></td></tr></table></figure>
<p>在 scikit-learn 的 <code>LinearRegression</code>
模型中，截距（intercept）和系数（coefficients）分别存储在拟合模型的
<code>intercept_</code> 和 <code>coef_</code> 属性中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Intercept: <span class="subst">&#123;house_lm.intercept_:<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Coefficients:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> name, coef <span class="keyword">in</span> <span class="built_in">zip</span>(predictors, house_lm.coef_):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27; <span class="subst">&#123;name&#125;</span>: <span class="subst">&#123;coef&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这些系数的解释与简单线性回归相同：在其他变量 <span
class="math inline">\(X_k\)</span>（当 <span class="math inline">\(k
\neq j\)</span>）保持不变的情况下，预测值 <span
class="math inline">\(Y\)</span> 每当 <span
class="math inline">\(X_j\)</span> 变化 1 个单位时，便按系数 <span
class="math inline">\(b_j\)</span>
的大小变化。例如，在房屋中增加一平方英尺的可用面积，估计价值大约增加 229
美元；增加 1,000 平方英尺的可用面积则意味着价值增加约 228,800 美元。</p>
<h4 id="评估模型">评估模型</h4>
<p>Assessing the Model</p>
<p>从数据科学角度来看，最重要的性能指标是<strong>均方根误差（Root Mean
Squared Error, RMSE）</strong>。RMSE 是预测值 <span
class="math inline">\(\hat y_i\)</span> 与真实值 <span
class="math inline">\(y_i\)</span> 的误差平方的平均值再开方： <span
class="math display">\[
\text{RMSE}=\sqrt{\frac{\sum_{i=1}^{n}(y_i-\hat y_i)^2}{n}}
\]</span></p>
<p>它衡量模型的整体精度，也是将该模型与其他模型（包括用机器学习方法拟合的模型）进行比较的基础。与
RMSE 类似的是<strong>残差标准误差（Residual Standard Error,
RSE）</strong>。在这种情况下有 <span class="math inline">\(p\)</span>
个自变量，RSE 公式为：</p>
<p><span class="math display">\[
\text{RSE}=\sqrt{\frac{\sum_{i=1}^{n}(y_i-\hat y_i)^2}{n-p-1}}
\]</span></p>
<p>唯一的区别在于分母——RSE
用自由度而不是样本数（参见本书第116页“自由度”部分）。在实践中，对于线性回归，RMSE
与 RSE 的差别通常非常小，尤其是在大数据场景下。</p>
<p>R 语言的 <code>summary</code> 函数可以计算 RSE
以及回归模型的其他指标：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">summary<span class="punctuation">(</span>house_lm<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Call:</span><br><span class="line">lm(formula = AdjSalePrice ~ SqFtTotLiving + SqFtLot + Bathrooms +</span><br><span class="line">Bedrooms + BldgGrade, data = house, na.action = na.omit)</span><br><span class="line"></span><br><span class="line">Residuals:</span><br><span class="line">    Min       1Q   Median       3Q      Max</span><br><span class="line">-1199479 -118908  -20977   87435  9473035</span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">               Estimate  Std. Error  t value  Pr(&gt;|t|)</span><br><span class="line">(Intercept)    -5.219e+05  1.565e+04 -33.342  &lt; 2e-16 ***</span><br><span class="line">SqFtTotLiving   2.288e+02  3.899e+00  58.694  &lt; 2e-16 ***</span><br><span class="line">SqFtLot        -6.047e-02  6.118e-02  -0.988   0.323</span><br><span class="line">Bathrooms      -1.944e+04  3.625e+03  -5.363  8.27e-08 ***</span><br><span class="line">Bedrooms       -4.777e+04  2.490e+03 -19.187  &lt; 2e-16 ***</span><br><span class="line">BldgGrade       1.061e+05  2.396e+03  44.277  &lt; 2e-16 ***</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1</span><br><span class="line"></span><br><span class="line">Residual standard error: 261300 on 22681 degrees of freedom</span><br><span class="line">Multiple R-squared: 0.5406, Adjusted R-squared: 0.5405</span><br><span class="line">F-statistic: 5338 on 5 and 22681 DF, p-value: &lt; 2.2e-16</span><br></pre></td></tr></table></figure>
<p>scikit-learn 提供了许多用于回归和分类的评估指标。这里我们用
<code>mean_squared_error</code> 计算 RMSE，用 <code>r2_score</code>
计算决定系数（R²）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fitted = house_lm.predict(house[predictors])</span><br><span class="line">RMSE = np.sqrt(mean_squared_error(house[outcome], fitted))</span><br><span class="line">r2 = r2_score(house[outcome], fitted)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;RMSE: <span class="subst">&#123;RMSE:<span class="number">.0</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;r2: <span class="subst">&#123;r2:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>在 Python 中可以使用 <code>statsmodels</code>
对回归模型做更详细的分析：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model = sm.OLS(house[outcome], house[predictors].assign(const=<span class="number">1</span>))</span><br><span class="line">results = model.fit()</span><br><span class="line">results.summary()</span><br></pre></td></tr></table></figure>
<p>这里用到的 pandas 方法 <code>assign</code> 会在自变量中添加一个值为 1
的常数列，这是为了在模型中包含截距项所必需的。</p>
<p><strong>另一个有用的指标：决定系数（R²）</strong>：你在软件输出中还会看到另一个有用的指标：<strong>决定系数</strong>（coefficient
of determination），也叫 <strong>R² 统计量</strong>或
<strong>R-squared</strong>。R² 的取值范围从 0 到
1，用于衡量模型解释了数据变异的比例。它主要用于回归的解释性分析中，用来评估模型对数据的拟合程度。R²
的公式是： <span class="math display">\[
R^2 = 1 - \frac{\sum_{i=1}^n (y_i-\hat{y}_i)^2}{\sum_{i=1}^n
(y_i-\bar{y})^2}
\]</span></p>
<p>分母与 <span class="math inline">\(Y\)</span> 的方差成比例。R
的输出中还报告了 <strong>调整后的 R²</strong>（adjusted
R-squared），它会根据自由度进行调整，相当于对模型中增加的预测变量进行惩罚。在大数据集的多元回归中，调整后的
R² 与普通 R² 差别通常不大。</p>
<p>在估计系数的同时，R 和 statsmodels 还会报告系数的标准误差（SE）以及
<strong>t 统计量</strong>：</p>
<p><span class="math display">\[
t_b=\frac{b}{SE(b)}
\]</span></p>
<p><strong>t 统计量</strong>（以及其对应的 <strong>p
值</strong>）衡量系数在统计意义上是否显著——也就是它是否超出了预测变量和目标变量之间随机关系所能产生的范围。
t 统计量越高（p
值越低），该预测变量的重要性就越显著。由于“简约”是模型的重要特征，因此像
t
统计量这样的工具非常有用，可以用来指导是否在模型中保留某个预测变量（参见第156页“模型选择与逐步回归”）。</p>
<blockquote>
<p><strong>警告</strong></p>
<p>除了 t 统计量，R 和其他软件包通常还会报告 <strong>p 值</strong>（在 R
输出中为 Pr(&gt;|t|)）以及 <strong>F
统计量</strong>。数据科学家通常不会深入解释这些统计量或“统计显著性”问题，而是主要把
<strong>t 统计量</strong>作为一个有用的参考：</p>
<ul>
<li><strong>高 t 统计量（p 值接近 0）</strong> →
该预测变量应保留在模型中</li>
<li><strong>非常低的 t 统计量</strong> → 该预测变量可以考虑移除 关于 p
值的更多讨论，见第106页“p 值”。</li>
</ul>
</blockquote>
<h4 id="交叉验证">交叉验证</h4>
<p>Cross-Validation</p>
<p>经典的统计回归指标（R²、F 统计量和 p 值）都是“样本内”指标（in-sample
metrics）——也就是应用于用于拟合模型的同一批数据。直觉上，你可以看出，留出部分原始数据，不用它来拟合模型，再将模型应用于这部分留出样本（holdout
sample）来测试其表现，会更有意义。通常，你会用大部分数据来训练模型，用一小部分来测试模型。</p>
<p>这种“样本外”验证（out-of-sample
validation）的思路并不新鲜，但直到大数据集更普遍出现后才真正流行起来；在小数据集下，分析人员通常希望用到全部数据以拟合出最优模型。</p>
<p>然而，使用单个留出样本会引入不确定性：如果你选择了不同的留出样本，评估结果会有多大差别？</p>
<p><strong>交叉验证</strong>将留出样本的思路扩展为多个连续的留出样本。基本
<strong>k 折交叉验证</strong>（k-fold cross-validation）的算法如下：</p>
<ol type="1">
<li>把数据中的 <span class="math inline">\(1/k\)</span>
留作测试样本（holdout sample）。</li>
<li>用剩余的 <span class="math inline">\(k-1\)</span>
份数据训练模型。</li>
<li>用模型对这 <span class="math inline">\(1/k\)</span>
的留出样本进行预测，记录所需的模型评估指标。</li>
<li>把第一个 <span class="math inline">\(1/k\)</span>
的数据放回，换取下一个 <span
class="math inline">\(1/k\)</span>（不包括已抽取过的记录）。</li>
<li>重复步骤 2 和 3。</li>
<li>持续重复，直到每条记录都曾被用作留出样本。</li>
<li>对所有折叠的评估指标进行平均或合并。</li>
</ol>
<p>这种把数据分成训练集（training sample）和留出集（training
sample）的划分方式，也称为一个<strong>折叠（fold）</strong>。</p>
<h4 id="模型选择与逐步回归">模型选择与逐步回归</h4>
<p>Model Selection and Stepwise Regression</p>
<p>在某些问题中，回归模型可能有许多可用作预测变量的特征。例如，为了预测房屋价格，我们可以添加地下室面积、建造年份等额外变量。在
<strong>R</strong> 中，这些变量很容易添加到回归方程里：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">house_full <span class="operator">&lt;-</span> lm<span class="punctuation">(</span>AdjSalePrice <span class="operator">~</span> SqFtTotLiving <span class="operator">+</span> SqFtLot <span class="operator">+</span> Bathrooms <span class="operator">+</span></span><br><span class="line">Bedrooms <span class="operator">+</span> BldgGrade <span class="operator">+</span> PropertyType <span class="operator">+</span> NbrLivingUnits <span class="operator">+</span></span><br><span class="line">SqFtFinBasement <span class="operator">+</span> YrBuilt <span class="operator">+</span> YrRenovated <span class="operator">+</span></span><br><span class="line">NewConstruction<span class="punctuation">,</span></span><br><span class="line">data<span class="operator">=</span>house<span class="punctuation">,</span> na.action<span class="operator">=</span>na.omit<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>在 <strong>Python</strong>
中，我们需要先把类别型和布尔型变量转换为数值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">predictors = [<span class="string">&#x27;SqFtTotLiving&#x27;</span>, <span class="string">&#x27;SqFtLot&#x27;</span>, <span class="string">&#x27;Bathrooms&#x27;</span>, <span class="string">&#x27;Bedrooms&#x27;</span>, <span class="string">&#x27;BldgGrade&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;PropertyType&#x27;</span>, <span class="string">&#x27;NbrLivingUnits&#x27;</span>, <span class="string">&#x27;SqFtFinBasement&#x27;</span>, <span class="string">&#x27;YrBuilt&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;YrRenovated&#x27;</span>, <span class="string">&#x27;NewConstruction&#x27;</span>]</span><br><span class="line">X = pd.get_dummies(house[predictors], drop_first=<span class="literal">True</span>)</span><br><span class="line">X[<span class="string">&#x27;NewConstruction&#x27;</span>] = [<span class="number">1</span> <span class="keyword">if</span> nc <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> nc <span class="keyword">in</span> X[<span class="string">&#x27;NewConstruction&#x27;</span>]]</span><br><span class="line">house_full = sm.OLS(house[outcome], X.assign(const=<span class="number">1</span>))</span><br><span class="line">results = house_full.fit()</span><br><span class="line">results.summary()</span><br></pre></td></tr></table></figure>
<p>然而，添加更多变量并不一定意味着我们得到了更好的模型。统计学家遵循奥卡姆剃刀原则（Occam’s
razor）来指导模型选择：在其他条件相同的情况下，应该优先使用更简单的模型，而不是更复杂的模型。</p>
<p>在训练数据中，增加变量总是会降低 <strong>RMSE</strong> 并提高
<strong>R²</strong>，因此这些指标并不能很好地指导模型选择。一种把模型复杂度纳入考虑的方法是使用<strong>调整后的
R²</strong>：</p>
<p><span class="math display">\[
R^2_{\text{adj}} = 1 - (1-R^2)\frac{n-1}{n-P-1}
\]</span></p>
<p>其中 <span class="math inline">\(n\)</span> 是样本数，<span
class="math inline">\(P\)</span> 是模型中的变量数。</p>
<blockquote>
<p><strong>警告</strong>:</p>
<p><strong>AIC、BIC 和 Mallows
Cp</strong>：20世纪70年代，日本著名统计学家赤池弘次（Hirotugu
Akaike）提出了一个指标 <strong>AIC</strong>（Akaike 信息准则，Akaike’s
Information
Criteria），它会对模型中新增的变量进行惩罚。对于回归模型，AIC 公式为：
<span class="math display">\[
AIC = 2P + n\log\left(\frac{RSS}{n}\right)
\]</span></p>
<p>其中 <span class="math inline">\(P\)</span> 是变量数，<span
class="math inline">\(n\)</span> 是样本数。目标是找到<strong>使 AIC
最小的模型</strong>；如果多加了 <span class="math inline">\(k\)</span>
个变量，模型会受到 <span class="math inline">\(2k\)</span> 的惩罚。</p>
<p>AIC 有一些常见变体：</p>
<ul>
<li><strong>AICc</strong>：AIC 在小样本情况下的修正版本。</li>
<li><strong>BIC</strong>（Bayesian information
criteria，贝叶斯信息准则）：类似 AIC，但对新增变量的惩罚更强。</li>
<li><strong>Mallows Cp</strong>：Colin Mallows 提出的 AIC 变体。</li>
</ul>
<p>这些指标通常在训练集（样本内）上报告；如果数据科学家使用留出样本（holdout
data）来评估模型，就不必过于担心这些指标之间的差异或其背后的理论。</p>
</blockquote>
<p>如何找到最小 AIC 或最大调整后 R²
的模型呢？一种方法是搜索所有可能的模型，称为<strong>全子集回归（all
subset
regression）</strong>。这种方法计算量很大，对于包含大量数据和变量的问题来说不可行。一个更有吸引力的替代方法是使用<strong>逐步回归（stepwise
regression）</strong>。</p>
<ul>
<li>可以从完整模型开始，逐步去掉没有显著贡献的变量（称为<strong>后向消除
backward elimination</strong>）。</li>
<li>也可以从常数模型开始，逐步加入变量（<strong>前向选择 forward
selection</strong>）。</li>
<li>还可以交替加入和移除预测变量，以找到能降低 AIC 或调整后 R²
的模型。</li>
</ul>
<p><strong>R</strong> 中 Venables 和 Ripley 提供的 <strong>MASS</strong>
包就有一个逐步回归函数 <strong>stepAIC</strong>：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>MASS<span class="punctuation">)</span></span><br><span class="line">step <span class="operator">&lt;-</span> stepAIC<span class="punctuation">(</span>house_full<span class="punctuation">,</span> direction<span class="operator">=</span><span class="string">&quot;both&quot;</span><span class="punctuation">)</span></span><br><span class="line">step</span><br></pre></td></tr></table></figure>
<p>示例输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Call:</span><br><span class="line">lm(formula = AdjSalePrice ~ SqFtTotLiving + Bathrooms + Bedrooms +</span><br><span class="line">BldgGrade + PropertyType + SqFtFinBasement + YrBuilt, data = house,</span><br><span class="line">na.action = na.omit)</span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">(Intercept)            SqFtTotLiving</span><br><span class="line">6.179e+06              1.993e+02</span><br><span class="line">Bathrooms              Bedrooms</span><br><span class="line">4.240e+04             -5.195e+04</span><br><span class="line">BldgGrade              PropertyTypeSingle Family</span><br><span class="line">1.372e+05              2.291e+04</span><br><span class="line">PropertyTypeTownhouse  SqFtFinBasement</span><br><span class="line">8.448e+04              7.047e+00</span><br><span class="line">YrBuilt</span><br><span class="line">-3.565e+03</span><br></pre></td></tr></table></figure>
<p>​</p>
<blockquote>
<p>个人注：以下是用gemini翻译 20250915 12:00</p>
</blockquote>
<p>scikit-learn 没有实现逐步回归的功能。我们在我们的 dmba 包中实现了
<code>stepwise_selection</code>、<code>forward_selection</code> 和
<code>backward_elimination</code> 函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">y = house[outcome]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_model</span>(<span class="params">variables</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(variables) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    model = LinearRegression()</span><br><span class="line">    model.fit(X[variables], y)</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">score_model</span>(<span class="params">model, variables</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(variables) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> AIC_score(y, [y.mean()] * <span class="built_in">len</span>(y), model, df=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> AIC_score(y, model.predict(X[variables]), model)</span><br><span class="line">best_model, best_variables = stepwise_selection(X.columns, train_model, score_model, verbose=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Intercept: <span class="subst">&#123;best_model.intercept_:<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Coefficients:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> name, coef <span class="keyword">in</span> <span class="built_in">zip</span>(best_variables, best_model.coef_):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27; <span class="subst">&#123;name&#125;</span>: <span class="subst">&#123;coef&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>定义一个函数，该函数为一组给定的变量返回一个拟合好的模型。定义一个函数，该函数为给定的模型和一组变量返回一个得分。在本例中，我们使用了
dmba 包中实现的 <code>AIC_score</code>。该函数选择了一个模型，其中
<code>house_full</code>
中的几个变量被剔除：<code>SqFtLot</code>、<code>NbrLivingUnits</code>、<code>YrRenovated</code>
和 <code>NewConstruction</code>。</p>
<p>更简单的方法是<strong>前向选择</strong>和<strong>后向选择</strong>。在前向选择中，你从零个预测变量开始，然后逐一添加，每一步都添加对
<span class="math inline">\(R^2\)</span>
贡献最大的预测变量，当贡献不再具有统计显著性时停止。在后向选择，或者说后向消除中，你从完整模型开始，然后移除不具有统计显著性的预测变量，直到你剩下的模型中所有预测变量都具有统计显著性。</p>
<p><strong>惩罚回归</strong>在精神上与 <strong>AIC</strong>
相似。它不是通过显式地搜索离散的模型集合，而是在模型拟合方程中加入一个惩罚，对拥有太多变量（参数）的模型进行惩罚。惩罚回归不会像逐步、前向和后向选择那样完全消除预测变量，而是通过减少系数来应用惩罚，在某些情况下会使其接近于零。常见的惩罚回归方法是<strong>岭回归</strong>（ridge
regression）和 <strong>Lasso 回归</strong>（lasso regression）。</p>
<p>逐步回归和所有子集回归都是<strong>样本内</strong>方法，用于评估和调整模型。这意味着模型选择可能存在<strong>过拟合</strong>（拟合数据中的噪声），并且在应用于新数据时性能可能不佳。避免这种情况的一种常见方法是使用<strong>交叉验证</strong>来验证模型。在线性回归中，过拟合通常不是一个主要问题，因为数据被强加了一个简单的（线性）全局结构。对于更复杂的模型类型，特别是那些对局部数据结构作出反应的迭代过程，交叉验证是一个非常重要的工具；详见第155页的“交叉验证”部分。</p>
<h4 id="加权回归">加权回归</h4>
<p>Weighted Regression</p>
<p>统计学家出于多种目的使用加权回归；尤其是在分析复杂调查数据时，它非常重要。数据科学家可能会在以下两种情况下发现加权回归很有用：</p>
<ol type="1">
<li><strong>逆方差加权</strong>：当不同观测值的测量精度不同时，可以采用这种方法；方差较高的观测值权重较低。</li>
<li><strong>多案例数据分析</strong>：当数据中的每一行代表多个原始观测值时，权重变量编码了每行所代表的原始观测值数量。</li>
</ol>
<p>以住房数据为例，较早的销售数据通常不如最近的销售数据可靠。我们可以使用
<code>DocumentDate</code> 来确定销售年份，并计算一个 <code>Weight</code>
变量，该变量是自2005年（数据开始年份）以来的年数：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>lubridate<span class="punctuation">)</span></span><br><span class="line">house<span class="operator">$</span>Year <span class="operator">=</span> year<span class="punctuation">(</span>house<span class="operator">$</span>DocumentDate<span class="punctuation">)</span></span><br><span class="line">house<span class="operator">$</span>Weight <span class="operator">=</span> house<span class="operator">$</span>Year <span class="operator">-</span> <span class="number">2005</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">house[<span class="string">&#x27;Year&#x27;</span>] = [<span class="built_in">int</span>(date.split(<span class="string">&#x27;-&#x27;</span>)[<span class="number">0</span>]) <span class="keyword">for</span> date <span class="keyword">in</span> house.DocumentDate]</span><br><span class="line">house[<span class="string">&#x27;Weight&#x27;</span>] = house.Year - <span class="number">2005</span></span><br></pre></td></tr></table></figure>
<p>我们可以使用 <code>lm</code> 函数中的 <code>weight</code>
参数计算加权回归：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">house_wt <span class="operator">&lt;-</span> lm<span class="punctuation">(</span>AdjSalePrice <span class="operator">~</span> SqFtTotLiving <span class="operator">+</span> SqFtLot <span class="operator">+</span> Bathrooms <span class="operator">+</span></span><br><span class="line">Bedrooms <span class="operator">+</span> BldgGrade<span class="punctuation">,</span></span><br><span class="line">data<span class="operator">=</span>house<span class="punctuation">,</span> weight<span class="operator">=</span>Weight<span class="punctuation">)</span></span><br><span class="line"><span class="built_in">round</span><span class="punctuation">(</span>cbind<span class="punctuation">(</span>house_lm<span class="operator">=</span>house_lm<span class="operator">$</span>coefficients<span class="punctuation">,</span></span><br><span class="line">house_wt<span class="operator">=</span>house_wt<span class="operator">$</span>coefficients<span class="punctuation">)</span><span class="punctuation">,</span> digits<span class="operator">=</span><span class="number">3</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">house_lm</th>
<th style="text-align: left;">house_wt</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">(Intercept)</td>
<td style="text-align: left;">-521871.368</td>
<td style="text-align: left;">-584189.329</td>
</tr>
<tr class="even">
<td style="text-align: left;">SqFtTotLiving</td>
<td style="text-align: left;">228.831</td>
<td style="text-align: left;">245.024</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SqFtLot</td>
<td style="text-align: left;">-0.060</td>
<td style="text-align: left;">-0.292</td>
</tr>
<tr class="even">
<td style="text-align: left;">Bathrooms</td>
<td style="text-align: left;">-19442.840</td>
<td style="text-align: left;">-26085.970</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Bedrooms</td>
<td style="text-align: left;">-47769.955</td>
<td style="text-align: left;">-53608.876</td>
</tr>
<tr class="even">
<td style="text-align: left;">BldgGrade</td>
<td style="text-align: left;">106106.963</td>
<td style="text-align: left;">115242.435</td>
</tr>
</tbody>
</table>
<p>加权回归中的系数与原始回归中的系数略有不同。</p>
<p>scikit-learn 中的大多数模型在其 <code>fit</code> 方法调用中都接受
<code>sample_weight</code> 作为关键字参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">predictors = [<span class="string">&#x27;SqFtTotLiving&#x27;</span>, <span class="string">&#x27;SqFtLot&#x27;</span>, <span class="string">&#x27;Bathrooms&#x27;</span>, <span class="string">&#x27;Bedrooms&#x27;</span>, <span class="string">&#x27;BldgGrade&#x27;</span>]</span><br><span class="line">outcome = <span class="string">&#x27;AdjSalePrice&#x27;</span></span><br><span class="line">house_wt = LinearRegression()</span><br><span class="line">house_wt.fit(house[predictors], house[outcome], sample_weight=house.Weight)</span><br></pre></td></tr></table></figure>
<p><strong>关键思想</strong></p>
<ul>
<li><strong>多元线性回归</strong>：对响应变量 <code>Y</code>
与多个预测变量 <code>X1, ..., Xp</code> 之间的关系进行建模。</li>
<li><strong>最重要的评估指标</strong>：评估模型的最重要指标是<strong>均方根误差
(RMSE)</strong> 和 <strong>R平方 (<span
class="math inline">\(R^2\)</span>)</strong>。</li>
<li><strong>系数的标准误</strong>：可用于衡量变量对模型贡献的可靠性。</li>
<li><strong>逐步回归</strong>：一种自动确定哪些变量应包含在模型中的方法。</li>
<li><strong>加权回归</strong>：用于在方程拟合过程中给予某些记录更多或更少的权重。</li>
</ul>
<h3 id="使用回归进行预测">使用回归进行预测</h3>
<p>Prediction Using Regression</p>
<p>在数据科学中，回归的主要目的是<strong>预测</strong>。这一点值得我们牢记，因为回归作为一种古老且成熟的统计方法，附带了一些与其作为<strong>解释性建模</strong>工具的传统角色更相关的“包袱（baggage）”，而这些包袱与预测的目的关系不大。</p>
<p><strong>使用回归进行预测的关键术语</strong></p>
<ul>
<li><strong>预测区间（Prediction interval）</strong>
围绕单个预测值的不确定性区间。</li>
<li><strong>外推法（Extrapolation）</strong>
将模型扩展到用于拟合它的数据范围之外。</li>
</ul>
<h4 id="外推的危险性">外推的危险性</h4>
<p>The Dangers of Extrapolation</p>
<p>回归模型不应该被用来进行<strong>外推</strong>，<strong>即预测超出其训练数据范围之外的值</strong>（不包括将回归用于时间序列预测的情况）。模型仅对那些数据中存在足够值的预测变量值有效（即使有足够的数据，也可能存在其他问题，详见第176页的“回归诊断”）。</p>
<p>举一个极端的例子，假设我们使用 <code>model_lm</code>
来预测一块5000平方英尺空地的价值。在这种情况下，所有与建筑物相关的预测变量值都将为0，而回归方程将得出一个荒谬的预测值：-521,900
+ 5,000 × -0.0605 =
-$522,202。为什么会发生这种情况？因为我们的数据只包含带有建筑物的地块，没有任何对应空地的记录。因此，模型没有任何信息来告诉它如何预测空地的销售价格。</p>
<h4 id="置信区间与预测区间">置信区间与预测区间</h4>
<p>Confidence and Prediction Intervals</p>
<p>统计学的大部分内容都涉及理解和衡量<strong>变异性</strong>（不确定性）。回归输出中报告的
<code>t</code> 统计量和 <code>p</code>
值以一种正式的方式处理了这个问题，这有时对于变量选择是有用的（详见第153页的“评估模型”）。更有用的指标是<strong>置信区间</strong>，它是不确定性区间，<strong>围绕着回归系数和预测值</strong>。理解这一点的一个简单方法是通过<strong>自助法（bootstrap）</strong>（关于一般的自助法程序，详见第61页）。在软件输出中最常见的回归置信区间是针对回归参数（系数）的。</p>
<p>以下是为具有P个预测变量和n个记录（行）的数据集生成回归参数（系数）置信区间的自助法算法：</p>
<ol type="1">
<li>将每一行（包括结果变量）视为一张单独的“票据”，并将所有n张票据放入一个盒子里。</li>
<li>随机抽取一张票据，记录下值，然后将其放回盒中。</li>
<li>重复步骤2共n次；你现在有了一个自助法重抽样样本。</li>
<li>对这个自助法样本进行回归拟合，并记录估计的系数。</li>
<li>重复步骤2到步骤4，例如1000次。</li>
<li>现在你拥有了每个系数的1000个自助法值；找到每个值的相应百分位数（例如，90%置信区间的第5和第95百分位数）。</li>
</ol>
<p>在 R 语言中，你可以使用 <code>Boot</code>
函数来生成实际的自助法置信区间，或者简单地使用 R
的常规输出中基于公式的区间。它们的<strong>概念含义和解释是相同的</strong>，并且对数据科学家来说不那么重要，因为它们关注的是回归系数。</p>
<p>对数据科学家来说，更重要的是围绕预测 <code>y</code> 值（<span
class="math inline">\(Y_i\)</span>）的区间。围绕 <span
class="math inline">\(Y_i\)</span> 的不确定性来自两个来源：</p>
<ul>
<li><strong>不确定性</strong>（Uncertainty）：关于相关的预测变量及其系数是什么（参考前面的自助法算法）。</li>
<li><strong>附加误差</strong>（Additional
error）：个体数据点固有的附加误差。</li>
</ul>
<p>个体数据点误差可以这样理解：即使我们确切知道回归方程是什么（例如，如果我们有海量的记录来拟合它），对于一组给定的预测变量值，实际的结果值仍然会存在差异。例如，几栋房子——每栋都有8个房间、6500平方英尺的土地、3个浴室和一个地下室——它们的价值可能不同。我们可以用拟合值中的<strong>残差</strong>（residuals）来模拟这种个体误差（individual
error）。</p>
<p>用于同时模拟回归模型误差和个体数据点误差的自助法算法如下所示：</p>
<ol type="1">
<li>从数据中抽取一个自助法样本（前面已详细说明）。</li>
<li>拟合回归模型，并预测新值。</li>
<li>从原始回归拟合中随机抽取一个残差，将其加到预测值上，并记录结果。</li>
<li>重复步骤1到3，例如1000次。</li>
<li>找到结果的2.5%和97.5%百分位数。</li>
</ol>
<blockquote>
<p>个人注：第 3 步（随机抽取残差加到预测值上）的例子</p>
<p>1、 假设我们有这样一个回归模型</p>
<p>我们用房屋面积预测房价（单位：美元）：</p>
<table>
<thead>
<tr class="header">
<th>面积 (X)</th>
<th>真实价格 (Y)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1000</td>
<td>200,000</td>
</tr>
<tr class="even">
<td>1500</td>
<td>250,000</td>
</tr>
<tr class="odd">
<td>2000</td>
<td>280,000</td>
</tr>
</tbody>
</table>
<p>我们拟合出一个简单回归：</p>
<p><span class="math display">\[
\hat Y = 100000 + 90 X
\]</span></p>
<p>这样预测值和残差分别是：</p>
<table>
<thead>
<tr class="header">
<th>X</th>
<th>真实 Y</th>
<th>预测 <span class="math inline">\(\hat Y\)</span></th>
<th>残差 <span class="math inline">\(r=Y-\hat Y\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1000</td>
<td>200000</td>
<td>190000</td>
<td>+10000</td>
</tr>
<tr class="even">
<td>1500</td>
<td>250000</td>
<td>235000</td>
<td>+15000</td>
</tr>
<tr class="odd">
<td>2000</td>
<td>280000</td>
<td>280000</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>2、 我们要预测一个新房屋</p>
<p>面积 <strong>1800 平方英尺</strong>。模型预测值：</p>
<p><span class="math display">\[
\hat Y_\text{new} = 100000 + 90*1800 = 262000
\]</span></p>
<p>但是我们知道模型有误差，于是用 bootstrap 残差来模拟。</p>
<p>3、 第 3 步：随机抽取一个残差，加到预测值上</p>
<ul>
<li>我们有原始残差集合 <span class="math inline">\(\{+10000, +15000,
0\}\)</span></li>
<li>假设第一次随机抽到 <strong>+15000</strong></li>
<li>那么新的“模拟观测值”就是</li>
</ul>
<p><span class="math display">\[
262000 + 15000 = 277000
\]</span></p>
<p>下一次 bootstrap 可能抽到残差 <strong>0</strong>，那么就是</p>
<p><span class="math display">\[
262000 + 0 = 262000
\]</span></p>
<p>再下一次抽到残差 <strong>+10000</strong>，就是</p>
<p><span class="math display">\[
262000 + 10000 = 272000
\]</span></p>
<p>4、 重复多次</p>
<p>我们重复这个过程（步骤1–3）1000次，就能得到
<strong>262000、272000、277000…</strong> 这样一堆“预测+误差”的值。</p>
<p>把这些值排序，取第2.5百分位和第97.5百分位，就得到了这个新房屋价格预测的<strong>95%预测区间</strong>。</p>
<p>5、 <strong>总结</strong>
第3步的“随机取残差加回预测值”就是用模型拟合后的残差来“模拟”未来观测的随机误差，让你不仅有一个点预测值，还有一个预测区间。</p>
</blockquote>
<p><strong>关键思想</strong></p>
<ul>
<li><strong>外推</strong>：超出数据范围的预测可能导致错误。</li>
<li><strong>置信区间</strong>：量化围绕<strong>回归系数</strong>的不确定性。</li>
<li><strong>预测区间</strong>：量化<strong>个体预测值</strong>的不确定性。</li>
<li><strong>软件输出</strong>：包括 R
在内的大多数软件都会使用公式生成预测和置信区间，作为默认或指定的输出。</li>
<li><strong>自助法</strong>：也可以用于生成预测和置信区间；其解释和思想是相同的。</li>
</ul>
<blockquote>
<p><strong>警告：</strong></p>
<p>预测区间还是置信区间？预测区间<strong>（prediction
interval）与</strong>单个值<strong>的不确定性有关，而</strong>置信区间<strong>（confidence
interval）与从</strong>多个值<strong>计算得出的</strong>均值<strong>或其他统计量有关。因此，</strong>预测区间通常会比相同值的置信区间宽得多。我们在自助法模型中通过选择一个单独的残差并将其附加到预测值上来模拟这种个体值误差。你应该使用哪一个？这取决于分析的背景和目的，但总的来说，数据科学家对<strong>特定的个体预测</strong>更感兴趣，因此<strong>预测区间</strong>会更合适。当你应该使用预测区间时却使用了置信区间，将<strong>大大低估</strong>给定预测值中的不确定性。</p>
</blockquote>
<h3 id="回归中的因子变量">回归中的因子变量</h3>
<p>Factor Variables in Regression</p>
<p><strong>因子变量</strong>，也称为<strong>分类变量</strong>（categorical
variables），取有限数量的离散值。例如，贷款用途可以是“债务整合”、“婚礼”、“汽车”等等。<strong>二元（binary）（是/否）变量</strong>，也叫<strong>指示变量</strong>（indicator
variabl），是因子变量的一种特殊情况。</p>
<p>回归模型需要数值输入，因此因子变量需要重新编码才能在模型中使用。最常见的方法是将一个因子变量转换为一组<strong>二元虚拟变量</strong>（binary
dummy variables）。</p>
<p><strong>因子变量的关键术语</strong></p>
<ul>
<li><p><strong>虚拟变量（Dummy variables）</strong>
由重新编码因子数据而来的二元 0-1 变量，用于回归和其他模型。</p></li>
<li><p><strong>参考编码（Reference coding）</strong>
统计学家最常用的编码类型，其中一个因子水平被用作参考，其他因子水平与该参考水平进行比较。
同义词：<strong>处理编码（treatment coding）</strong></p></li>
<li><p><strong>独热编码（One hot encoder）</strong>
机器学习社区常用的一种编码类型，其中所有因子水平都被保留。虽然对某些机器学习算法很有用，但这种方法不适用于多元线性回归。</p></li>
<li><p><strong>偏差编码（Deviation coding）</strong>
一种将每个水平与整体均值进行比较，而不是与参考水平进行比较的编码类型。
同义词：<strong>总和对比（sum contrasts）</strong></p></li>
</ul>
<h4 id="虚拟变量表示">虚拟变量表示</h4>
<p>Dummy Variables Representation</p>
<p>在金县住房数据中，有一个用于表示房产类型的因子变量；下面是其中六条记录的一个小样本：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">head<span class="punctuation">(</span>house<span class="punctuation">[</span><span class="punctuation">,</span> <span class="string">&#x27;PropertyType&#x27;</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">Source<span class="operator">:</span> local data frame <span class="punctuation">[</span><span class="number">6</span> x <span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">  PropertyType</span><br><span class="line">        <span class="punctuation">(</span>fctr<span class="punctuation">)</span></span><br><span class="line"><span class="number">1</span>  Multiplex</span><br><span class="line"><span class="number">2</span>  Single Family</span><br><span class="line"><span class="number">3</span>  Single Family</span><br><span class="line"><span class="number">4</span>  Single Family</span><br><span class="line"><span class="number">5</span>  Single Family</span><br><span class="line"><span class="number">6</span>  Townhouse</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">house.PropertyType.head()</span><br></pre></td></tr></table></figure>
<p>该变量有三个可能的值：<code>Multiplex</code>（多户住宅）、<code>Single Family</code>（独栋住宅）和
<code>Townhouse</code>（联排别墅）。为了使用这个因子变量，我们需要将其转换成一组二元变量。我们通过为因子变量的每个可能值创建一个二元变量来实现。在
R 语言中，我们使用 <code>model.matrix</code> 函数来完成此操作：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">prop_type_dummies <span class="operator">&lt;-</span> model.matrix<span class="punctuation">(</span><span class="operator">~</span>PropertyType <span class="operator">-</span><span class="number">1</span><span class="punctuation">,</span> data<span class="operator">=</span>house<span class="punctuation">)</span></span><br><span class="line">head<span class="punctuation">(</span>prop_type_dummies<span class="punctuation">)</span></span><br><span class="line">  PropertyTypeMultiplex PropertyTypeSingle Family PropertyTypeTownhouse</span><br><span class="line"><span class="number">1</span>                     <span class="number">1</span>                      <span class="number">0</span>                     <span class="number">0</span></span><br><span class="line"><span class="number">2</span>                     <span class="number">0</span>                      <span class="number">1</span>                     <span class="number">0</span></span><br><span class="line"><span class="number">3</span>                     <span class="number">0</span>                      <span class="number">1</span>                     <span class="number">0</span></span><br><span class="line"><span class="number">4</span>                     <span class="number">0</span>                      <span class="number">1</span>                     <span class="number">0</span></span><br><span class="line"><span class="number">5</span>                     <span class="number">0</span>                      <span class="number">1</span>                     <span class="number">0</span></span><br><span class="line"><span class="number">6</span>                     <span class="number">0</span>                      <span class="number">0</span>                     <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><code>model.matrix</code>
函数将数据框转换为适合线性模型的矩阵。具有三个不同水平的因子变量
<code>PropertyType</code>
被表示为一个三列的矩阵。在机器学习社区中，这种表示被称为<strong>独热编码</strong>（见第242页的“独热编码”）。</p>
<p>在 Python 中，我们可以使用 pandas 的 <code>get_dummies</code>
方法将分类变量转换为虚拟变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pd.get_dummies(house[<span class="string">&#x27;PropertyType&#x27;</span>]).head()</span><br><span class="line">pd.get_dummies(house[<span class="string">&#x27;PropertyType&#x27;</span>], drop_first=<span class="literal">True</span>).head()</span><br></pre></td></tr></table></figure>
<p>默认情况下，该函数返回分类变量的独热编码。关键字参数
<code>drop_first</code> 将返回 <strong>P-1</strong>
列。使用这个参数可以避免<strong>多重共线性</strong>问题。在某些机器学习算法中，例如<strong>最近邻算法</strong>和<strong>树模型</strong>，独热编码是表示因子变量的标准方法（例如，参见第249页的“树模型”）。</p>
<p>在回归设置中，一个具有 <span class="math inline">\(P\)</span>
个不同水平的因子变量通常只用一个具有 <span
class="math inline">\(P-1\)</span>
列的矩阵来表示。这是因为回归模型通常包含一个<strong>截距项</strong>。有了截距项，一旦你定义了
<span class="math inline">\(P-1\)</span> 个二元变量的值，第 <span
class="math inline">\(P\)</span>
个的值就已知了，可以被认为是多余的。添加第 <span
class="math inline">\(P\)</span>
列会导致<strong>多重共线性</strong>错误（详见第172页的“多重共线性”）。</p>
<p>参考编码：R
中的默认表示方法是使用第一个因子水平作为<strong>参考水平</strong>，并解释其他水平相对于该水平的差异。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lm<span class="punctuation">(</span>AdjSalePrice <span class="operator">~</span> SqFtTotLiving <span class="operator">+</span> SqFtLot <span class="operator">+</span> Bathrooms <span class="operator">+</span></span><br><span class="line">Bedrooms <span class="operator">+</span> BldgGrade <span class="operator">+</span> PropertyType<span class="punctuation">,</span> data<span class="operator">=</span>house<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><strong>输出结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Coefficients:</span><br><span class="line">(Intercept) SqFtTotLiving</span><br><span class="line">-4.468e+05 2.234e+02</span><br><span class="line">SqFtLot Bathrooms</span><br><span class="line">-7.037e-02 -1.598e+04</span><br><span class="line">Bedrooms BldgGrade</span><br><span class="line">-5.089e+04 1.094e+05</span><br><span class="line">PropertyTypeSingle Family PropertyTypeTownhouse</span><br><span class="line">-8.468e+04 -1.151e+05</span><br></pre></td></tr></table></figure>
<p><code>get_dummies</code> 方法接受一个可选的关键字参数
<code>drop_first</code>，用来排除第一个因子作为参考：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">predictors = [<span class="string">&#x27;SqFtTotLiving&#x27;</span>, <span class="string">&#x27;SqFtLot&#x27;</span>, <span class="string">&#x27;Bathrooms&#x27;</span>, <span class="string">&#x27;Bedrooms&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;BldgGrade&#x27;</span>, <span class="string">&#x27;PropertyType&#x27;</span>]</span><br><span class="line">X = pd.get_dummies(house[predictors], drop_first=<span class="literal">True</span>)</span><br><span class="line">house_lm_factor = LinearRegression()</span><br><span class="line">house_lm_factor.fit(X, house[outcome])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Intercept: <span class="subst">&#123;house_lm_factor.intercept_:<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Coefficients:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> name, coef <span class="keyword">in</span> <span class="built_in">zip</span>(X.columns, house_lm_factor.coef_):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27; <span class="subst">&#123;name&#125;</span>: <span class="subst">&#123;coef&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>R 回归的输出结果显示了两个与 <code>PropertyType</code>
对应的系数：<code>PropertyTypeSingle Family</code> 和
<code>PropertyTypeTownhouse</code>。由于当
<code>PropertyTypeSingle Family == 0</code> 且
<code>PropertyTypeTownhouse == 0</code> 时，<code>Multiplex</code>
的值被隐式定义，因此没有 <code>Multiplex</code>
的系数。这些系数被解释为相对于 <code>Multiplex</code>
的相对值，因此，一个独栋家庭住宅（Single
Family）的价值比多户住宅（Multiplex）低近
$85,000，而一个联排别墅（Townhouse）的价值则低超过 $150,000。</p>
<blockquote>
<p><strong>警告</strong></p>
<p>不同的因子编码方式：<strong>有几种不同的编码因子变量的方法，统称为</strong>对比编码系统<strong>（contrast
coding systems）。例如，</strong>偏差编码<strong>（deviation
coding），也称为</strong>总和对比<strong>（sum
contrasts），将每个水平与整体均值进行比较。另一种对比是</strong>多项式编码<strong>（polynomial
coding），它适用于</strong>有序因子<strong>；详见第169页的“有序因子变量”部分。除了有序因子之外，数据科学家通常不会遇到除了</strong>参考编码<strong>或</strong>独热编码**之外的任何其他编码类型。</p>
</blockquote>
<h4 id="具有许多水平的因子变量">具有许多水平的因子变量</h4>
<p>Factor Variables with Many Levels</p>
<p>有些因子变量可能会产生大量的二元虚拟变量，例如邮政编码就是一个因子变量，而美国有43,000个邮政编码。在这种情况下，有必要探索数据以及预测变量和结果之间的关系，以确定这些类别中是否包含有用的信息。如果包含，你还必须决定是保留所有因子水平，还是应该进行合并。</p>
<p>在金县（King County）的住房数据中，有80个邮政编码有房屋销售记录：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table<span class="punctuation">(</span>house<span class="operator">$</span>ZipCode<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">98001</th>
<th style="text-align: left;">98002</th>
<th style="text-align: left;">...</th>
<th style="text-align: left;">98199</th>
<th style="text-align: left;">98224</th>
<th style="text-align: left;">98288</th>
<th style="text-align: left;">98354</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">358</td>
<td style="text-align: left;">180</td>
<td style="text-align: left;">...</td>
<td style="text-align: left;">393</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">9</td>
</tr>
</tbody>
</table>
<p>pandas 数据框的 <code>value_counts</code> 方法返回相同的信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame(house[<span class="string">&#x27;ZipCode&#x27;</span>].value_counts()).transpose()</span><br></pre></td></tr></table></figure>
<p>邮政编码是一个重要的变量，因为它代表了位置对房屋价值的影响。包含所有水平需要79个系数，对应79个自由度。原始模型
<code>house_lm</code>
只有5个自由度；参见第153页的“评估模型”。此外，有几个邮政编码只有一次销售记录。在某些问题中，你可以通过使用邮政编码的前两位或三位数字来合并它们，这对应于一个次级大都市地理区域。对于金县，几乎所有的销售都发生在
980xx 或 981xx，所以这种方法没有帮助。</p>
<p>另一种方法是根据另一个变量，如销售价格，对邮政编码进行分组。更好的方法是使用<strong>初始模型的残差</strong>来形成邮政编码组。以下
R 语言中的 <code>dplyr</code> 代码将80个邮政编码基于
<code>house_lm</code> 回归模型的残差中位数合并成五个组：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zip_groups <span class="operator">&lt;-</span> house <span class="operator">%&gt;%</span></span><br><span class="line">mutate<span class="punctuation">(</span>resid <span class="operator">=</span> residuals<span class="punctuation">(</span>house_lm<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span></span><br><span class="line">group_by<span class="punctuation">(</span>ZipCode<span class="punctuation">)</span> <span class="operator">%&gt;%</span></span><br><span class="line">summarize<span class="punctuation">(</span>med_resid <span class="operator">=</span> median<span class="punctuation">(</span>resid<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">cnt <span class="operator">=</span> n<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span></span><br><span class="line">arrange<span class="punctuation">(</span>med_resid<span class="punctuation">)</span> <span class="operator">%&gt;%</span></span><br><span class="line">mutate<span class="punctuation">(</span>cum_cnt <span class="operator">=</span> <span class="built_in">cumsum</span><span class="punctuation">(</span>cnt<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">ZipGroup <span class="operator">=</span> ntile<span class="punctuation">(</span>cum_cnt<span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">house <span class="operator">&lt;-</span> house <span class="operator">%&gt;%</span></span><br><span class="line">left_join<span class="punctuation">(</span>select<span class="punctuation">(</span>zip_groups<span class="punctuation">,</span> ZipCode<span class="punctuation">,</span> ZipGroup<span class="punctuation">)</span><span class="punctuation">,</span> by<span class="operator">=</span><span class="string">&#x27;ZipCode&#x27;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>为每个邮政编码计算残差中位数，然后使用 <code>ntile</code>
函数将按中位数排序的邮政编码分成五个组。有关如何将此作为回归项来改进原始拟合的示例，请参阅第172页的“混杂变量”。</p>
<p>在 Python 中，我们可以按如下方式计算此信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">zip_groups = pd.DataFrame([</span><br><span class="line">    *pd.DataFrame(&#123;</span><br><span class="line">        <span class="string">&#x27;ZipCode&#x27;</span>: house[<span class="string">&#x27;ZipCode&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;residual&#x27;</span> : house[outcome] - house_lm.predict(house[predictors]),</span><br><span class="line">    &#125;)</span><br><span class="line">    .groupby([<span class="string">&#x27;ZipCode&#x27;</span>])</span><br><span class="line">    .apply(<span class="keyword">lambda</span> x: &#123;</span><br><span class="line">        <span class="string">&#x27;ZipCode&#x27;</span>: x.iloc[<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">        <span class="string">&#x27;count&#x27;</span>: <span class="built_in">len</span>(x),</span><br><span class="line">        <span class="string">&#x27;median_residual&#x27;</span>: x.residual.median()</span><br><span class="line">    &#125;)</span><br><span class="line">]).sort_values(<span class="string">&#x27;median_residual&#x27;</span>)</span><br><span class="line">zip_groups[<span class="string">&#x27;cum_count&#x27;</span>] = np.cumsum(zip_groups[<span class="string">&#x27;count&#x27;</span>])</span><br><span class="line">zip_groups[<span class="string">&#x27;ZipGroup&#x27;</span>] = pd.qcut(zip_groups[<span class="string">&#x27;cum_count&#x27;</span>], <span class="number">5</span>, labels=<span class="literal">False</span>,</span><br><span class="line">retbins=<span class="literal">False</span>)</span><br><span class="line">to_join = zip_groups[[<span class="string">&#x27;ZipCode&#x27;</span>, <span class="string">&#x27;ZipGroup&#x27;</span>]].set_index(<span class="string">&#x27;ZipCode&#x27;</span>)</span><br><span class="line">house = house.join(to_join, on=<span class="string">&#x27;ZipCode&#x27;</span>)</span><br><span class="line">house[<span class="string">&#x27;ZipGroup&#x27;</span>] = house[<span class="string">&#x27;ZipGroup&#x27;</span>].astype(<span class="string">&#x27;category&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>利用残差来指导回归拟合的概念是建模过程中的一个基本步骤；详见第176页的“回归诊断”。</p>
<h4 id="有序因子变量">有序因子变量</h4>
<p>Ordered Factor Variables</p>
<p>有些因子变量反映了因子的水平高低；这些变量被称为<strong>有序因子变量</strong>或<strong>有序分类变量</strong>。例如，贷款评级可以是A、B、C等——每个评级都比前一个评级风险更高。通常，有序因子变量可以直接转换为数值并使用。例如，<code>BldgGrade</code>（建筑等级）就是一个有序因子变量。表4-1中展示了几种等级类型。虽然这些等级有特定的含义，但其数值从低到高排列，对应着更高等级的住宅。在第150页“多元线性回归”中拟合的回归模型
<code>house_lm</code> 中，<code>BldgGrade</code>
被视为一个数值变量。</p>
<p><img src="/img3/面向数据科学家的实用统计学/T4.1.png" alt="T4.1" style="zoom:50%;" /></p>
<p>将有序因子视为数值变量可以保留其包含的顺序信息，而如果将其转换为因子变量，这些信息就会丢失。</p>
<p><strong>关键思想</strong></p>
<ul>
<li><strong>因子变量</strong>：需要转换为数值变量才能在回归模型中使用。</li>
<li><strong>编码方法</strong>：对一个具有 <span
class="math inline">\(P\)</span>
个不同值的因子变量进行编码最常用的方法是使用 <span
class="math inline">\(P-1\)</span>
个<strong>虚拟变量</strong>来表示。</li>
<li><strong>水平过多的因子变量</strong>：即使在非常大的数据集中，具有许多水平的因子变量也可能需要合并为具有较少水平的变量。</li>
<li><strong>有序因子</strong>：某些因子的水平是有序的，可以表示为一个单独的数值变量。</li>
</ul>
<h3 id="解释回归方程">解释回归方程</h3>
<p>Interpreting the Regression Equation</p>
<p>在数据科学中，回归最主要的应用是预测某个<strong>因变量</strong>（结果变量）。然而，在某些情况下，从方程本身获得洞见以理解预测变量和结果之间的关系本质也很有价值。本节提供了关于如何检查和解释回归方程的指导。</p>
<p><strong>解释回归方程的关键术语</strong></p>
<ul>
<li><p><strong>相关变量（Correlated variables）</strong>
当预测变量高度相关时，很难解释单个系数。</p></li>
<li><p><strong>多重共线性（Multicollinearity）</strong>
当预测变量之间存在完全或接近完全的相关性时，回归可能不稳定或无法计算。
同义词：<strong>共线性（collinearity）</strong></p></li>
<li><p><strong>混杂变量（Confounding variables）</strong>
一个重要的预测变量，当被遗漏时，会导致回归方程中出现虚假关系。</p></li>
<li><p><strong>主效应（Main effects）</strong>
一个预测变量与结果变量之间的关系，独立于其他变量。</p></li>
<li><p><strong>交互作用（Interactions）</strong>
两个或多个预测变量与响应变量之间的相互依存关系。</p></li>
</ul>
<h4 id="相关预测变量">相关预测变量</h4>
<p>Correlated Predictors</p>
<p>在多元回归中，预测变量通常彼此之间存在相关性。举个例子，我们可以检查在第156页“模型选择与逐步回归”中拟合的模型
<code>step_lm</code> 的回归系数。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">step_lm<span class="operator">$</span>coefficients</span><br><span class="line"><span class="punctuation">(</span>Intercept<span class="punctuation">)</span> SqFtTotLiving       Bathrooms</span><br><span class="line"> <span class="number">6.178645e+06</span>  <span class="number">1.992776e+02</span>    <span class="number">4.239616e+04</span></span><br><span class="line">     Bedrooms     BldgGrade PropertyTypeSingle Family</span><br><span class="line"> <span class="operator">-</span><span class="number">5.194738e+04</span>  <span class="number">1.371596e+05</span>    <span class="number">2.291206e+04</span></span><br><span class="line">PropertyTypeTownhouse SqFtFinBasement         YrBuilt</span><br><span class="line">  <span class="number">8.447916e+04</span>    <span class="number">7.046975e+00</span>   <span class="operator">-</span><span class="number">3.565425e+03</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Intercept: <span class="subst">&#123;best_model.intercept_:<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Coefficients:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> name, coef <span class="keyword">in</span> <span class="built_in">zip</span>(best_variables, best_model.coef_):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27; <span class="subst">&#123;name&#125;</span>: <span class="subst">&#123;coef&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><code>Bedrooms</code>
的系数是<strong>负数</strong>！这暗示着给一栋房子增加一间卧室会降低其价值。这怎么可能呢？这是因为<strong>预测变量之间是相关的</strong>：更大的房子往往有更多的卧室，而真正驱动房屋价值的是<strong>面积</strong>，而不是卧室的数量。你可以这样理解：考虑两栋面积完全相同的房子，我们有理由认为卧室更多但更小的那栋房子会不那么受欢迎。</p>
<p>拥有相关联的预测变量会使解释回归系数的符号和值变得困难（并且可能夸大估计值的标准误）。卧室数量、房屋面积和浴室数量这几个变量都是相互关联的。以下面的
R 语言示例为例，它拟合了一个新的回归模型，从方程中移除了
<code>SqFtTotLiving</code>、<code>SqFtFinBasement</code> 和
<code>Bathrooms</code> 变量。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">update<span class="punctuation">(</span>step_lm<span class="punctuation">,</span> .</span><br><span class="line"><span class="operator">~</span></span><br><span class="line">.</span><br><span class="line"><span class="operator">-</span> SqFtTotLiving <span class="operator">-</span> SqFtFinBasement <span class="operator">-</span> Bathrooms<span class="punctuation">)</span></span><br><span class="line">Call<span class="operator">:</span></span><br><span class="line">lm<span class="punctuation">(</span>formula <span class="operator">=</span> AdjSalePrice <span class="operator">~</span> Bedrooms <span class="operator">+</span> BldgGrade <span class="operator">+</span> PropertyType <span class="operator">+</span></span><br><span class="line">YrBuilt<span class="punctuation">,</span> data <span class="operator">=</span> house<span class="punctuation">,</span> na.action <span class="operator">=</span> na.omit<span class="punctuation">)</span></span><br><span class="line">Coefficients<span class="operator">:</span></span><br><span class="line">      <span class="punctuation">(</span>Intercept<span class="punctuation">)</span>         Bedrooms</span><br><span class="line">          <span class="number">4913973</span>          <span class="number">27151</span></span><br><span class="line">        BldgGrade PropertyTypeSingle Family</span><br><span class="line">           <span class="number">248998</span>         <span class="operator">-</span><span class="number">19898</span></span><br><span class="line">PropertyTypeTownhouse         YrBuilt</span><br><span class="line">        <span class="operator">-</span><span class="number">47355</span>         <span class="operator">-</span><span class="number">3212</span></span><br></pre></td></tr></table></figure>
<p><code>update</code>
函数可用于从模型中添加或移除变量。现在，<code>Bedrooms</code>
的系数变为<strong>正数</strong>——这与我们的预期相符（尽管在移除了房屋面积等变量后，它实际上充当了房屋大小的替代变量）。</p>
<p>在 Python 中，没有与 R 的 <code>update</code>
函数等效的功能。我们需要使用修改后的预测变量列表重新拟合模型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">predictors = [<span class="string">&#x27;Bedrooms&#x27;</span>, <span class="string">&#x27;BldgGrade&#x27;</span>, <span class="string">&#x27;PropertyType&#x27;</span>, <span class="string">&#x27;YrBuilt&#x27;</span>]</span><br><span class="line">outcome = <span class="string">&#x27;AdjSalePrice&#x27;</span></span><br><span class="line">X = pd.get_dummies(house[predictors], drop_first=<span class="literal">True</span>)</span><br><span class="line">reduced_lm = LinearRegression()</span><br><span class="line">reduced_lm.fit(X, house[outcome])</span><br></pre></td></tr></table></figure>
<p>相关变量只是解释回归系数的一个问题。在 <code>house_lm</code>
模型中，没有变量来解释房屋的位置，这个模型将非常不同的区域类型混在一起。<strong>位置</strong>可能是一个<strong>混杂变量</strong>；更多讨论请参见第172页的“混杂变量”。</p>
<h4 id="多重共线性">多重共线性</h4>
<p>Multicollinearity</p>
<p><strong>多重共线性</strong>是由<strong>相关变量</strong>所引发的极端情况——预测变量之间存在<strong>冗余</strong>。当一个预测变量可以表示为其他预测变量的线性组合时，就会出现<strong>完全多重共线性</strong>。</p>
<p>多重共线性通常发生在以下情况：</p>
<ul>
<li><strong>重复包含</strong>：一个变量被错误地包含了多次。</li>
<li><strong>不当的虚拟变量</strong>：由一个因子变量创建了 <span
class="math inline">\(P\)</span> 个虚拟变量，而不是正确的 <span
class="math inline">\(P-1\)</span>
个（参见第163页的“回归中的因子变量”）。</li>
<li><strong>高度相关</strong>：两个变量几乎是完全相关的。</li>
</ul>
<p>在回归分析中，<strong>必须处理多重共线性</strong>——应该移除变量直到多重共线性消失。在存在完全多重共线性的情况下，回归模型没有明确定义的解。许多软件，包括
R 和
Python，会自动处理某些类型的多重共线性。例如，如果在房屋数据回归中两次包含
<code>SqFtTotLiving</code> 变量，其结果与 <code>house_lm</code>
模型的结果相同。在<strong>非完全多重共线性</strong>的情况下，软件可能会得到一个解，但结果可能<strong>不稳定</strong>。</p>
<blockquote>
<p><strong>通用注解</strong></p>
<p>对于非线性回归方法，如树模型、聚类和最近邻算法，多重共线性不是一个大问题，在这些方法中保留全部
<span class="math inline">\(P\)</span> 个虚拟变量（而不是 <span
class="math inline">\(P-1\)</span>
个）可能是可取的。即便如此，在这些方法中，预测变量的非冗余性仍然是一种优点。</p>
</blockquote>
<h4 id="混杂变量">混杂变量</h4>
<p>Confounding Variables</p>
<p><strong>相关变量</strong>的问题在于<strong>加入</strong>了太多相似的变量，而<strong>混杂变量</strong>的问题在于<strong>遗漏</strong>了重要的变量。如果对回归方程的系数进行天真的解释，可能会得出无效的结论。</p>
<p>以第151页“示例：金县住房数据”中的金县回归方程 <code>house_lm</code>
为例。<code>SqFtLot</code>、<code>Bathrooms</code> 和
<code>Bedrooms</code>
的回归系数都是负的。这个原始回归模型没有包含代表<strong>位置</strong>的变量——而位置是房屋价格的一个非常重要的预测因子。</p>
<p>为了对位置进行建模，我们引入一个ZipGroup变量，它将邮政编码分为五组，从最便宜（1）到最贵（5）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lm<span class="punctuation">(</span>formula <span class="operator">=</span> AdjSalePrice <span class="operator">~</span> SqFtTotLiving <span class="operator">+</span> SqFtLot <span class="operator">+</span> Bathrooms <span class="operator">+</span></span><br><span class="line">Bedrooms <span class="operator">+</span> BldgGrade <span class="operator">+</span> PropertyType <span class="operator">+</span> ZipGroup<span class="punctuation">,</span> data <span class="operator">=</span> house<span class="punctuation">,</span></span><br><span class="line">na.action <span class="operator">=</span> na.omit<span class="punctuation">)</span></span><br><span class="line">Coefficients<span class="operator">:</span></span><br><span class="line">      <span class="punctuation">(</span>Intercept<span class="punctuation">)</span>   SqFtTotLiving</span><br><span class="line">       <span class="operator">-</span><span class="number">6.666e+05</span>    <span class="number">2.106e+02</span></span><br><span class="line">        SqFtLot       Bathrooms</span><br><span class="line">        <span class="number">4.550e-01</span>    <span class="number">5.928e+03</span></span><br><span class="line">       Bedrooms       BldgGrade</span><br><span class="line">      <span class="operator">-</span><span class="number">4.168e+04</span>    <span class="number">9.854e+04</span></span><br><span class="line">PropertyTypeSingle Family PropertyTypeTownhouse</span><br><span class="line">       <span class="number">1.932e+04</span>    <span class="operator">-</span><span class="number">7.820e+04</span></span><br><span class="line">         ZipGroup2      ZipGroup3</span><br><span class="line">        <span class="number">5.332e+04</span>    <span class="number">1.163e+05</span></span><br><span class="line">         ZipGroup4      ZipGroup5</span><br><span class="line">        <span class="number">1.784e+05</span>    <span class="number">3.384e+05</span></span><br></pre></td></tr></table></figure>
<p>Python 中相同的模型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">predictors = [<span class="string">&#x27;SqFtTotLiving&#x27;</span>, <span class="string">&#x27;SqFtLot&#x27;</span>, <span class="string">&#x27;Bathrooms&#x27;</span>, <span class="string">&#x27;Bedrooms&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;BldgGrade&#x27;</span>, <span class="string">&#x27;PropertyType&#x27;</span>, <span class="string">&#x27;ZipGroup&#x27;</span>]</span><br><span class="line">outcome = <span class="string">&#x27;AdjSalePrice&#x27;</span></span><br><span class="line">X = pd.get_dummies(house[predictors], drop_first=<span class="literal">True</span>)</span><br><span class="line">confounding_lm = LinearRegression()</span><br><span class="line">confounding_lm.fit(X, house[outcome])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Intercept: <span class="subst">&#123;confounding_lm.intercept_:<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Coefficients:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> name, coef <span class="keyword">in</span> <span class="built_in">zip</span>(X.columns, confounding_lm.coef_):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27; <span class="subst">&#123;name&#125;</span>: <span class="subst">&#123;coef&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><code>ZipGroup</code>
显然是一个重要的变量：位于最贵邮政编码组的房屋，其估计销售价格要高出近
$340,000。现在，<code>SqFtLot</code> 和 <code>Bathrooms</code>
的系数变为正数，增加一个浴室会使销售价格增加 $5,928。</p>
<p><code>Bedrooms</code>
的系数仍然是负数。虽然这看起来不合直觉，但这在房地产领域是一个众所周知的现象。对于居住面积和浴室数量相同的房屋，卧室数量更多（因此卧室更小）的房屋通常与较低的价值相关联。</p>
<h4 id="交互作用与主效应">交互作用与主效应</h4>
<p>Interactions and Main Effects</p>
<p>统计学家喜欢区分<strong>主效应</strong>（或称自变量 independent
variables）和<strong>主效应之间的交互作用</strong>。主效应通常是指回归方程中的预测变量。当模型中只使用主效应时，一个隐含的假设是：预测变量与响应变量之间的关系是<strong>独立于</strong>其他预测变量的。然而，情况往往并非如此。</p>
<p>例如，在第172页“混杂变量”中拟合的金县住房数据模型包含了几个变量作为主效应，其中包括ZipCode。在房地产中，位置是决定一切的关键，因此很自然地会假设，房屋面积与销售价格之间的关系取决于位置。一个建在低租金区域的大房子，其价值不会与建在昂贵区域的大房子相同。在
R 中，你可以使用 <code>*</code>
运算符来包含变量之间的交互作用。对于金县数据，以下代码拟合了
<code>SqFtTotLiving</code> 和 <code>ZipGroup</code> 之间的交互作用：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lm<span class="punctuation">(</span>formula <span class="operator">=</span> AdjSalePrice <span class="operator">~</span> SqFtTotLiving <span class="operator">*</span> ZipGroup <span class="operator">+</span> SqFtLot <span class="operator">+</span></span><br><span class="line">Bathrooms <span class="operator">+</span> Bedrooms <span class="operator">+</span> BldgGrade <span class="operator">+</span> PropertyType<span class="punctuation">,</span> data <span class="operator">=</span> house<span class="punctuation">,</span></span><br><span class="line">na.action <span class="operator">=</span> na.omit<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><strong>输出结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Coefficients:</span><br><span class="line">(Intercept) ... SqFtTotLiving:ZipGroup2 ...</span><br></pre></td></tr></table></figure>
<p>得到的模型有四个新项：<code>SqFtTotLiving:ZipGroup2</code>、<code>SqFtTotLiving:ZipGroup3</code>
等等。</p>
<p>在 Python 中，我们需要使用 <code>statsmodels</code>
包来训练包含交互作用的线性回归模型。这个包的设计类似于
R，并允许使用公式接口来定义模型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">model = smf.ols(formula=<span class="string">&#x27;AdjSalePrice ~ SqFtTotLiving*ZipGroup + SqFtLot + &#x27;</span> +</span><br><span class="line"><span class="string">&#x27;Bathrooms + Bedrooms + BldgGrade + PropertyType&#x27;</span>, data=house)</span><br><span class="line">results = model.fit()</span><br><span class="line">results.summary()</span><br></pre></td></tr></table></figure>
<p><code>statsmodels</code> 包会自动处理分类变量（例如
<code>ZipGroup[T.1]</code>、<code>PropertyType[T.Single Family]</code>）和交互项（例如
<code>SqFtTotLiving:ZipGroup[T.1]</code>）。</p>
<p>位置和房屋面积似乎存在强烈的交互作用。对于最低 <code>ZipGroup</code>
中的房屋，其斜率与主效应 <code>SqFtTotLiving</code>
的斜率相同，即每平方英尺118美元（这是因为 R
对因子变量使用参考编码；参见第163页的“回归中的因子变量”）。对于最高
<code>ZipGroup</code> 中的房屋，斜率是主效应加上
<code>SqFtTotLiving:ZipGroup5</code> 的总和，即115美元 + 227美元 =
每平方英尺342美元。换句话说，与增加一平方英尺的平均价值提升相比，在最昂贵的邮政编码组中增加一平方英尺，其预测销售价格的提升因子几乎是三倍。</p>
<blockquote>
<p><strong>知识点</strong></p>
<p>包含交互项的模型选择：在涉及许多变量的问题中，决定模型应包含哪些交互项可能具有挑战性。通常采取几种不同的方法：</p>
<ul>
<li>在某些问题中，<strong>先验知识和直觉</strong>可以指导选择要包含在模型中的交互项。</li>
<li>可以使用<strong>逐步选择</strong>（参见第156页的“模型选择与逐步回归”）来筛选各种模型。</li>
<li><strong>惩罚回归</strong>可以自动拟合一大组可能的交互项。</li>
<li>也许最常见的方法是使用<strong>树模型</strong>及其后代，如<strong>随机森林</strong>和<strong>梯度提升树</strong>。这类模型会自动搜索最佳的交互项；参见第249页的“树模型”。</li>
</ul>
</blockquote>
<p><strong>关键思想</strong></p>
<ul>
<li><strong>相关预测变量</strong>：由于预测变量之间的相关性，在解释多元线性回归的系数时必须谨慎。</li>
<li><strong>多重共线性</strong>：可能导致回归方程拟合时的数值不稳定。</li>
<li><strong>混杂变量</strong>：一个被模型遗漏的重要预测变量，可能导致回归方程中出现虚假关系。</li>
<li><strong>交互项</strong>：如果变量与响应变量之间的关系是相互依存的，则需要引入两个变量之间的交互项。</li>
</ul>
<h3 id="回归诊断">回归诊断</h3>
<p>Regression Diagnostics</p>
<p>在<strong>解释性建模</strong>（explanatory
modeling）（即研究背景）中，除了前面提到的指标（参见第153页的“评估模型”）之外，还会采取各种步骤来评估模型对数据的拟合程度；这些步骤大多基于<strong>残差分析</strong>。它们不直接关乎预测准确性，但可以在预测场景中提供有用的洞见。</p>
<p><strong>回归诊断的关键术语</strong></p>
<ul>
<li><p><strong>标准化残差（Standardized residuals）</strong>
残差除以残差的标准误。</p></li>
<li><p><strong>离群值（Outliers）</strong>
与数据其余部分（或预测结果）相距甚远的记录（或结果值）。</p></li>
<li><p><strong>影响力值（Influential value）</strong>
其存在或缺失对回归方程产生重大影响的值或记录。</p></li>
<li><p><strong>杠杆值（Leverage）</strong>
单个记录对回归方程影响的程度。
同义词：<strong>帽子值（hat-value）</strong></p></li>
<li><p><strong>非正态残差（Non-normal residuals）</strong>
残差不呈正态分布会使回归的一些技术要求失效，但在数据科学中通常不是一个主要问题。</p></li>
<li><p><strong>异方差性（Heteroskedasticity）</strong>
当结果变量的某些范围内的残差具有更高的方差时（可能表明方程中缺少某个预测变量）。</p></li>
<li><p><strong>偏残差图（Partial residual plots）</strong>
一个诊断图，用于揭示结果变量与单个预测变量之间的关系。
同义词：<strong>增广变量图（added variables plot）</strong></p></li>
</ul>
<h4 id="离群值">离群值</h4>
<p>Outliers</p>
<p>一般来说，一个极端值，也称为<strong>离群值</strong>，是与大多数其他观测值相距甚远的值。正如在处理位置和变异性估计时需要处理离群值一样（参见第7页的“位置估计”和第13页的“变异性估计”），离群值也可能给回归模型带来问题。在回归中，离群值是指其实际
<span class="math inline">\(y\)</span>
值与预测值相距甚远的记录。你可以通过检查<strong>标准化残差</strong>来检测离群值，标准化残差是将残差除以残差的标准误。</p>
<p>没有统计学理论可以区分离群值和非离群值。相反，有一些（任意的）经验法则来界定一个观测值需要与主体数据相距多远才能被称为离群值。例如，对于箱线图，离群值是那些离箱体边界太远的数据点（参见第20页的“百分位数与箱线图”），其中“太远”是指“超过四分位距的1.5倍”。在回归中，<strong>标准化残差</strong>是通常用于判断一条记录是否被归类为离群值的指标。标准化残差可以被解释为“距离回归线有多少个标准误”。</p>
<p>让我们在 R 中对邮政编码98105的所有房屋销售数据拟合一个回归模型：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">house_98105 <span class="operator">&lt;-</span> house<span class="punctuation">[</span>house<span class="operator">$</span>ZipCode <span class="operator">==</span> <span class="number">98105</span><span class="punctuation">,</span><span class="punctuation">]</span></span><br><span class="line">lm_98105 <span class="operator">&lt;-</span> lm<span class="punctuation">(</span>AdjSalePrice <span class="operator">~</span> SqFtTotLiving <span class="operator">+</span> SqFtLot <span class="operator">+</span> Bathrooms <span class="operator">+</span></span><br><span class="line">Bedrooms <span class="operator">+</span> BldgGrade<span class="punctuation">,</span> data<span class="operator">=</span>house_98105<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>在 Python 中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">house_98105 = house.loc[house[<span class="string">&#x27;ZipCode&#x27;</span>] == <span class="number">98105</span>, ]</span><br><span class="line">predictors = [<span class="string">&#x27;SqFtTotLiving&#x27;</span>, <span class="string">&#x27;SqFtLot&#x27;</span>, <span class="string">&#x27;Bathrooms&#x27;</span>, <span class="string">&#x27;Bedrooms&#x27;</span>, <span class="string">&#x27;BldgGrade&#x27;</span>]</span><br><span class="line">outcome = <span class="string">&#x27;AdjSalePrice&#x27;</span></span><br><span class="line">house_outlier = sm.OLS(house_98105[outcome],</span><br><span class="line">house_98105[predictors].assign(const=<span class="number">1</span>))</span><br><span class="line">result_98105 = house_outlier.fit()</span><br></pre></td></tr></table></figure>
<p>我们使用 R 中的 <code>rstandard</code> 函数提取标准化残差，并使用
<code>order</code> 函数获取最小残差的索引：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sresid <span class="operator">&lt;-</span> rstandard<span class="punctuation">(</span>lm_98105<span class="punctuation">)</span></span><br><span class="line">idx <span class="operator">&lt;-</span> order<span class="punctuation">(</span>sresid<span class="punctuation">)</span></span><br><span class="line">sresid<span class="punctuation">[</span>idx<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="number">20429</span></span><br><span class="line"><span class="operator">-</span><span class="number">4.326732</span></span><br></pre></td></tr></table></figure>
<p>在 <code>statsmodels</code> 中，使用 <code>OLSInfluence</code>
来分析残差：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">influence = OLSInfluence(result_98105)</span><br><span class="line">sresiduals = influence.resid_studentized_internal</span><br><span class="line">sresiduals.idxmin(), sresiduals.<span class="built_in">min</span>()</span><br></pre></td></tr></table></figure>
<p>模型中最大的高估值比回归线高出四个多标准误，这相当于高估了$757,754。与此离群值对应的原始数据记录在
R 中如下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">house_98105<span class="punctuation">[</span>idx<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;AdjSalePrice&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;SqFtTotLiving&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;SqFtLot&#x27;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&#x27;Bathrooms&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;Bedrooms&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;BldgGrade&#x27;</span><span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line">AdjSalePrice SqFtTotLiving SqFtLot Bathrooms Bedrooms BldgGrade</span><br><span class="line"><span class="punctuation">(</span>dbl<span class="punctuation">)</span> <span class="punctuation">(</span>int<span class="punctuation">)</span> <span class="punctuation">(</span>int<span class="punctuation">)</span> <span class="punctuation">(</span>dbl<span class="punctuation">)</span> <span class="punctuation">(</span>int<span class="punctuation">)</span> <span class="punctuation">(</span>int<span class="punctuation">)</span></span><br><span class="line"><span class="number">20429</span> <span class="number">119748</span> <span class="number">2900</span> <span class="number">7276</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>在 Python 中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">outlier = house_98105.loc[sresiduals.idxmin(), :]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;AdjSalePrice&#x27;</span>, outlier[outcome])</span><br><span class="line"><span class="built_in">print</span>(outlier[predictors])</span><br></pre></td></tr></table></figure>
<p>在这种情况下，似乎这条记录出了问题：在这个邮政编码中，如此大小的房屋通常售价要远高于$119,748。图4-4展示了此次销售的法定契据摘录：很明显，此次销售仅涉及该房产的部分权益。在这种情况下，该离群值对应一次异常销售，不应被包含在回归分析中。离群值也可能是由其他问题造成的，例如“粗心”的数据录入或单位不匹配（例如，以千美元为单位报告销售额而不是以美元为单位）。</p>
<p><img src="/img3/面向数据科学家的实用统计学/F4.4.png" alt="F4.4" style="zoom:50%;" /></p>
<p>对于大数据问题，离群值通常不会对用于预测新数据的回归拟合造成问题。<strong>然而，在异常检测中，离群值是核心，因为找到离群值正是其全部目的。离群值也可能对应于欺诈或意外行为。无论如何，检测离群值可能是一个关键的商业需求。</strong></p>
<h4 id="影响力值">影响力值</h4>
<p>Influential Values</p>
<p>如果一个值在被移除后会显著改变回归方程，那么它就被称为<strong>有影响力的观测值</strong>。在回归中，这样的值不一定与大的残差相关联。例如，考虑图4-5中的两条回归线。实线对应于使用所有数据拟合的回归，而虚线对应于移除了右上角数据点后的回归。很明显，这个数据值对回归有巨大的影响，尽管它本身并不是一个大的离群值（从完整回归的角度来看）。这个数据值被认为对回归具有<strong>高杠杆</strong>。</p>
<p><img src="/img3/面向数据科学家的实用统计学/F4.5.png" alt="F4.5" style="zoom:33%;" /></p>
<p>除了标准化残差（参见第177页的“离群值”）之外，统计学家还开发了几个指标来确定单个记录对回归的影响。一个常见的杠杆度量是<strong>帽子值（hat-value）</strong>；当帽子值高于
<span class="math inline">\(2(P+1)/n\)</span>
时，表明该数据值具有高杠杆。</p>
<p>另一个指标是<strong>库克距离（Cook’s
distance）</strong>，它将影响力定义为<strong>杠杆值</strong>和<strong>残差大小</strong>的组合。一个经验法则是，如果库克距离超过
<span
class="math inline">\(4/(n-P-1)\)</span>，则该观测值具有高影响力。</p>
<p><img src="/img3/面向数据科学家的实用统计学/F4.6.png" alt="F4.6" style="zoom:50%;" /></p>
<p><strong>影响力图</strong>（或<strong>气泡图</strong>）(influence plot
or bubble
plot)将标准化残差、帽子值和库克距离组合在一个图表中。图4-6展示了金县房屋数据的影响力图，可以用以下
R 代码创建：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std_resid <span class="operator">&lt;-</span> rstandard<span class="punctuation">(</span>lm_98105<span class="punctuation">)</span></span><br><span class="line">cooks_D <span class="operator">&lt;-</span> cooks.distance<span class="punctuation">(</span>lm_98105<span class="punctuation">)</span></span><br><span class="line">hat_values <span class="operator">&lt;-</span> hatvalues<span class="punctuation">(</span>lm_98105<span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>subset<span class="punctuation">(</span>hat_values<span class="punctuation">,</span> cooks_D <span class="operator">&gt;</span> <span class="number">0.08</span><span class="punctuation">)</span><span class="punctuation">,</span> subset<span class="punctuation">(</span>std_resid<span class="punctuation">,</span> cooks_D <span class="operator">&gt;</span> <span class="number">0.08</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">xlab<span class="operator">=</span><span class="string">&#x27;hat_values&#x27;</span><span class="punctuation">,</span> ylab<span class="operator">=</span><span class="string">&#x27;std_resid&#x27;</span><span class="punctuation">,</span></span><br><span class="line">cex<span class="operator">=</span><span class="number">10</span><span class="operator">*</span><span class="built_in">sqrt</span><span class="punctuation">(</span>subset<span class="punctuation">(</span>cooks_D<span class="punctuation">,</span> cooks_D <span class="operator">&gt;</span> <span class="number">0.08</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> pch<span class="operator">=</span><span class="number">16</span><span class="punctuation">,</span> col<span class="operator">=</span><span class="string">&#x27;lightgrey&#x27;</span><span class="punctuation">)</span></span><br><span class="line">points<span class="punctuation">(</span>hat_values<span class="punctuation">,</span> std_resid<span class="punctuation">,</span> cex<span class="operator">=</span><span class="number">10</span><span class="operator">*</span><span class="built_in">sqrt</span><span class="punctuation">(</span>cooks_D<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">abline<span class="punctuation">(</span>h<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">2.5</span><span class="punctuation">,</span> <span class="number">2.5</span><span class="punctuation">)</span><span class="punctuation">,</span> lty<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>以下是创建类似图表的 Python 代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">influence = OLSInfluence(result_98105)</span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">ax.axhline(-<span class="number">2.5</span>, linestyle=<span class="string">&#x27;--&#x27;</span></span><br><span class="line">, color=<span class="string">&#x27;C1&#x27;</span>)</span><br><span class="line">ax.axhline(<span class="number">2.5</span>, linestyle=<span class="string">&#x27;--&#x27;</span></span><br><span class="line">, color=<span class="string">&#x27;C1&#x27;</span>)</span><br><span class="line">ax.scatter(influence.hat_matrix_diag, influence.resid_studentized_internal,</span><br><span class="line">s=<span class="number">1000</span> * np.sqrt(influence.cooks_distance[<span class="number">0</span>]),</span><br><span class="line">alpha=<span class="number">0.5</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;hat values&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;studentized residuals&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>图中有几个数据点明显对回归表现出较大的影响力。库克距离可以使用
<code>cooks.distance</code> 函数计算，你可以使用 <code>hatvalues</code>
来计算诊断值。帽子值绘制在 x 轴上，残差绘制在 y
轴上，点的大小与库克距离的值相关。</p>
<p><img src="/img3/面向数据科学家的实用统计学/T4.2.png" alt="T4.2" style="zoom:50%;" /></p>
<p>表4-2比较了使用完整数据集和移除了高影响力数据点（库克距离 &gt;
0.08）的回归结果。 <code>Bathrooms</code> 的回归系数变化相当大。</p>
<p>为了拟合一个能够可靠预测未来数据的回归模型，识别有影响力的观测值仅在较小的数据集中有用。对于包含许多记录的回归模型，单个观测值不太可能具有足够的权重来对拟合方程产生极端影响（尽管回归模型仍然可能存在大的离群值）。然而，对于<strong>异常检测</strong>而言，识别有影响力的观测值可能非常有用。</p>
<h4 id="异方差性非正态性与相关误差">异方差性、非正态性与相关误差</h4>
<p>Heteroskedasticity, Non-Normality, and Correlated Errors</p>
<p>统计学家们非常关注残差的分布。事实证明，在广泛的分布假设下，<strong>普通最小二乘法（OLS）</strong>（参见第148页的“最小二乘法”）是无偏的，并且在某些情况下是“最优”的估计量。这意味着在大多数问题中，数据科学家无需过度关注残差的分布。</p>
<p>残差的分布主要关系到<strong>正式统计推断</strong>（假设检验和 p
值）的有效性，而这对于主要关注<strong>预测准确性</strong>的数据科学家来说，其重要性是最小的。<strong>正态分布的误差</strong>是一个信号，表明模型是完整的；而<strong>非正态分布的误差</strong>则表明模型可能遗漏了某些东西。为了使正式推断完全有效，残差被假定为<strong>正态分布</strong>、具有<strong>相同的方差</strong>且<strong>相互独立</strong>。数据科学家可能需要关注这一点的一个领域是预测值的标准置信区间计算，它基于关于残差的这些假设（参见第161页的“置信区间与预测区间”）。</p>
<p>异方差性（Heteroskedasticity）是指在预测值的整个范围内缺乏恒定的残差方差。换句话说，在某些范围内的误差比其他范围更大。将数据可视化是分析残差的一种便捷方式。</p>
<p>以下 R 代码绘制了第177页“离群值”中拟合的 <code>lm_98105</code>
回归模型的绝对残差与预测值之间的关系图：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>resid <span class="operator">=</span> residuals<span class="punctuation">(</span>lm_98105<span class="punctuation">)</span><span class="punctuation">,</span> pred <span class="operator">=</span> predict<span class="punctuation">(</span>lm_98105<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">ggplot<span class="punctuation">(</span>df<span class="punctuation">,</span> aes<span class="punctuation">(</span>pred<span class="punctuation">,</span> <span class="built_in">abs</span><span class="punctuation">(</span>resid<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span> geom_point<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span> geom_smooth<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>图4-7显示了生成的图。使用
<code>geom_smooth</code>，可以很容易地叠加一个绝对残差的平滑曲线。该函数调用
<code>loess</code> 方法（局部加权散点图平滑），以在散点图中生成 x 轴和 y
轴变量之间关系的平滑估计（参见第185页的“散点图平滑器”）。</p>
<p><img src="/img3/面向数据科学家的实用统计学/F4.7.png" alt="F4.7" style="zoom:50%;" /></p>
<p>在 Python 中，<code>seaborn</code> 包的 <code>regplot</code>
函数可以创建类似的图：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">sns.regplot(result_98105.fittedvalues, np.<span class="built_in">abs</span>(result_98105.resid),</span><br><span class="line">scatter_kws=&#123;<span class="string">&#x27;alpha&#x27;</span>: <span class="number">0.25</span>&#125;, line_kws=&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;C1&#x27;</span>&#125;,</span><br><span class="line">lowess=<span class="literal">True</span>, ax=ax)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;predicted&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;abs(residual)&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>很明显，残差的方差随着房屋价值的升高而增大，但对于低价值的房屋也很大。这个图表明
<code>lm_98105</code> 存在异方差性误差。</p>
<blockquote>
<p><strong>知识点</strong></p>
<p>为什么数据科学家要关心异方差性？**异方差性表明预测误差对于预测值的不同范围有所不同，这可能暗示模型不完整。例如，<code>lm_98105</code>
中的异方差性可能表明回归模型未能解释高价值和低价值房屋中遗漏的某些因素。</p>
</blockquote>
<p><img src="/img3/面向数据科学家的实用统计学/F4.8.png" alt="F4.8" style="zoom:33%;" /></p>
<p>图4-8是 <code>lm_98105</code>
回归模型的标准化残差直方图。该分布的尾部明显比正态分布长，并且对较大的残差表现出轻微的偏斜。</p>
<p>统计学家也可能检查误差是否独立的假设。对于随时间或空间收集的数据尤其如此。德宾-沃森统计量（Durbin-Watson
statistic）可用于检测涉及时间序列数据的回归中是否存在显著的自相关。如果回归模型的误差是相关的，那么这些信息对于进行短期预测可能很有用，并且应该被纳入模型中。有关如何将自相关信息纳入时间序列数据回归模型的更多信息，请参阅
Galit Shmueli 和 Kenneth Lichtendahl（Axelrod
Schnall，2018）撰写的《实用时间序列预测与
R，第2版》。如果目标是长期预测或解释性模型，微观层面上过度的自相关数据可能会分散注意力。在这种情况下，可能需要进行平滑处理，或者从一开始就以较低的粒度收集数据。</p>
<p>即使回归模型违反了某个分布假设，我们是否应该关心呢？在数据科学中，兴趣主要在于<strong>预测准确性</strong>，因此对异方差性进行一些检查可能是必要的。你可能会发现数据中存在模型尚未捕获的某种信号。然而，仅仅为了验证正式统计推断（p
值、F 统计量等）而满足分布假设，对数据科学家来说并没有那么重要。</p>
<blockquote>
<p><strong>通用注解</strong></p>
<p>散点图平滑器<strong>（Scatterplot
Smoothers）：回归是关于建模响应变量和预测变量之间的关系。在评估回归模型时，使用</strong>散点图平滑器**以可视化方式突出两个变量之间的关系是很有用的。</p>
<p>例如，在图4-7中，绝对残差与预测值之间关系的平滑曲线显示，残差的方差取决于残差的值。在本例中，使用了
<code>loess</code> 函数；<code>loess</code>
通过重复拟合一系列局部回归到连续子集上来生成平滑曲线。虽然
<code>loess</code> 可能是最常用的平滑器，但 R
中还有其他散点图平滑器，例如 <code>super smooth (supsmu)</code>
和<strong>核平滑（kernel smoothing, ksmooth）</strong>。在 Python
中，我们可以在 <code>scipy</code> (<code>wiener</code> 或
<code>sav</code>) 和 <code>statsmodels</code>
(<code>kernel_regression</code>)
中找到更多的平滑器。为了评估回归模型，通常无需担心这些散点图平滑器的具体细节。</p>
</blockquote>
<h4 id="偏残差图与非线性">偏残差图与非线性</h4>
<p>Partial Residual Plots and Nonlinearity</p>
<p><strong>偏残差图</strong>是一种可视化工具，用于评估估计的拟合效果，以及它如何解释一个预测变量与结果之间的关系。偏残差图的基本思想是<strong>隔离</strong>一个预测变量与响应变量之间的关系，同时<strong>考虑所有其他预测变量</strong>的影响。</p>
<p>偏残差可以被视为一个“合成结果”值，它结合了基于单个预测变量的预测值和完整回归方程的实际残差。预测变量
<span class="math inline">\(X_i\)</span>
的偏残差是<strong>普通残差加上与 <span
class="math inline">\(X_i\)</span> 相关的回归项</strong>：</p>
<p><span class="math display">\[
\text{偏残差} = \text{残差} + b_i X_i
\]</span></p>
<p>其中，<span class="math inline">\(b_i\)</span> 是估计的回归系数。R
中的 <code>predict</code> 函数有一个选项可以返回单个回归项 <span
class="math inline">\(b_i X_i\)</span>：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">terms <span class="operator">&lt;-</span> predict<span class="punctuation">(</span>lm_98105<span class="punctuation">,</span> type<span class="operator">=</span><span class="string">&#x27;terms&#x27;</span><span class="punctuation">)</span></span><br><span class="line">partial_resid <span class="operator">&lt;-</span> resid<span class="punctuation">(</span>lm_98105<span class="punctuation">)</span> <span class="operator">+</span> terms</span><br></pre></td></tr></table></figure>
<p>偏残差图将 <span class="math inline">\(X_i\)</span> 预测变量显示在 x
轴上，偏残差显示在 y 轴上。使用 <code>ggplot2</code>
可以很容易地叠加偏残差的平滑曲线：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>SqFtTotLiving <span class="operator">=</span> house_98105<span class="punctuation">[</span><span class="punctuation">,</span> <span class="string">&#x27;SqFtTotLiving&#x27;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">Terms <span class="operator">=</span> terms<span class="punctuation">[</span><span class="punctuation">,</span> <span class="string">&#x27;SqFtTotLiving&#x27;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">PartialResid <span class="operator">=</span> partial_resid<span class="punctuation">[</span><span class="punctuation">,</span> <span class="string">&#x27;SqFtTotLiving&#x27;</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">ggplot<span class="punctuation">(</span>df<span class="punctuation">,</span> aes<span class="punctuation">(</span>SqFtTotLiving<span class="punctuation">,</span> PartialResid<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">geom_point<span class="punctuation">(</span>shape<span class="operator">=</span><span class="number">1</span><span class="punctuation">)</span> <span class="operator">+</span> scale_shape<span class="punctuation">(</span>solid <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">geom_smooth<span class="punctuation">(</span>linetype<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">geom_line<span class="punctuation">(</span>aes<span class="punctuation">(</span>SqFtTotLiving<span class="punctuation">,</span> Terms<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><code>statsmodels</code> 包的 <code>sm.graphics.plot_ccpr</code>
方法可以创建类似的偏残差图：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sm.graphics.plot_ccpr(result_98105, <span class="string">&#x27;SqFtTotLiving&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>R 和 Python 的图表之间有一个常量偏移。在 R
中，添加了一个常量，使得项的均值为零。</p>
<p><img src="/img3/面向数据科学家的实用统计学/F4.9.png" alt="F4.9" style="zoom:50%;" /></p>
<p>由此生成的图表如图4-9所示。偏残差是对 <code>SqFtTotLiving</code>
对销售价格贡献的估计。<code>SqFtTotLiving</code>
与销售价格之间的关系显然是<strong>非线性的</strong>（虚线）。回归线（实线）低估了面积小于1000平方英尺的房屋价格，并高估了面积在2000到3000平方英尺之间的房屋价格。由于4000平方英尺以上的数据点太少，无法得出结论。</p>
<p>这种非线性关系在这种情况下是合理的：在一栋小房子中增加500英尺与在一栋大房子中增加500英尺所带来的价值差异是巨大的。这表明，我们应该考虑使用<strong>非线性项</strong>来替代简单的
<code>SqFtTotLiving</code>
线性项（参见第187页的“多项式和样条回归”）。</p>
<p><strong>关键思想</strong></p>
<ul>
<li><strong>离群值</strong>：虽然离群值可能会给小数据集带来问题，但其主要作用在于<strong>识别数据问题或定位异常情况</strong>。</li>
<li><strong>影响力</strong>：单个记录（包括回归离群值）在小数据集中可能对回归方程产生很大影响，但在大数据中这种影响会被稀释。</li>
<li><strong>残差分布</strong>：如果回归模型用于正式推断（p
值等），则应检查残差的分布假设。但总的来说，残差分布在数据科学中并不那么关键。</li>
<li><strong>偏残差图</strong>：可用于定性评估每个回归项的拟合效果，并可能导致模型的替代性设定。</li>
</ul>
<h3 id="多项式与样条回归">多项式与样条回归</h3>
<p>Polynomial and Spline Regression</p>
<p>响应变量与预测变量之间的关系不一定是线性的。例如，药物剂量与反应之间的关系通常是非线性的：将剂量加倍通常不会使反应也加倍。对产品的需求也不是营销投入的线性函数；在某个点之后，需求可能会饱和。有许多方法可以扩展回归模型以捕捉这些非线性效应。</p>
<p><strong>非线性回归的关键术语</strong></p>
<ul>
<li><strong>多项式回归（Polynomial regression）</strong>
在回归模型中添加多项式项（平方、立方等）。</li>
<li><strong>样条回归（Spline regression）</strong>
用一系列多项式分段来拟合一条平滑曲线。</li>
<li><strong>结点（Knots）</strong> 分隔样条分段的值。</li>
<li><strong>广义加性模型（Generalized additive models）</strong>
具有自动选择结点的样条模型。 同义词：<strong>GAM</strong></li>
</ul>
<blockquote>
<p><strong>知识点</strong></p>
<p>非线性回归（术语辨析）<strong>：当统计学家谈论</strong>非线性回归<strong>时，他们指的是</strong>不能<strong>使用最小二乘法进行拟合的模型。什么样的模型是非线性的？基本上，所有响应变量不能表示为预测变量或其某种变换的线性组合的模型都是非线性的。非线性回归模型更难拟合，计算也更密集，因为它需要</strong>数值优化**。因此，如果可能的话，通常首选使用线性模型。</p>
</blockquote>
<h4 id="多项式回归">多项式回归</h4>
<p>Polynomial</p>
<p><strong>多项式回归</strong>涉及在回归方程中包含多项式项。多项式回归的使用可以追溯到回归本身的发展时期，Gergonne
在1815年就发表了相关论文。例如，响应变量 <code>Y</code> 和预测变量
<code>X</code> 之间的二次回归方程形式如下： <span
class="math display">\[
Y = b_0 + b_1X + b_2X^2 + e
\]</span></p>
<p>多项式回归可以在 R 中通过 <code>poly</code>
函数进行拟合。例如，以下代码为金县住房数据中的
<code>SqFtTotLiving</code> 拟合了一个二次多项式：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lm<span class="punctuation">(</span>AdjSalePrice <span class="operator">~</span> poly<span class="punctuation">(</span>SqFtTotLiving<span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span> <span class="operator">+</span> SqFtLot <span class="operator">+</span></span><br><span class="line">BldgGrade <span class="operator">+</span> Bathrooms <span class="operator">+</span> Bedrooms<span class="punctuation">,</span></span><br><span class="line">data<span class="operator">=</span>house_98105<span class="punctuation">)</span></span><br><span class="line">Call<span class="operator">:</span></span><br><span class="line">lm<span class="punctuation">(</span>formula <span class="operator">=</span> AdjSalePrice <span class="operator">~</span> poly<span class="punctuation">(</span>SqFtTotLiving<span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span> <span class="operator">+</span> SqFtLot <span class="operator">+</span></span><br><span class="line">BldgGrade <span class="operator">+</span> Bathrooms <span class="operator">+</span> Bedrooms<span class="punctuation">,</span> data <span class="operator">=</span> house_98105<span class="punctuation">)</span></span><br><span class="line">Coefficients<span class="operator">:</span></span><br><span class="line"><span class="punctuation">(</span>Intercept<span class="punctuation">)</span> poly<span class="punctuation">(</span>SqFtTotLiving<span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="number">1</span> poly<span class="punctuation">(</span>SqFtTotLiving<span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="number">2</span></span><br><span class="line"><span class="operator">-</span><span class="number">402530.47</span> <span class="number">3271519.49</span> <span class="number">776934.02</span></span><br><span class="line">SqFtLot BldgGrade Bathrooms</span><br><span class="line"><span class="number">32.56</span> <span class="number">135717.06</span> <span class="operator">-</span><span class="number">1435.12</span></span><br><span class="line">Bedrooms</span><br><span class="line"><span class="operator">-</span><span class="number">9191.94</span></span><br></pre></td></tr></table></figure>
<p>在 <code>statsmodels</code> 中，我们使用
<code>I(SqFtTotLiving**2)</code> 将平方项添加到模型定义中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">model_poly = smf.ols(formula=<span class="string">&#x27;AdjSalePrice ~ SqFtTotLiving + &#x27;</span> +</span><br><span class="line"><span class="string">&#x27;+ I(SqFtTotLiving**2) + &#x27;</span> +</span><br><span class="line"><span class="string">&#x27;SqFtLot + Bathrooms + Bedrooms + BldgGrade&#x27;</span>, data=house_98105)</span><br><span class="line">result_poly = model_poly.fit()</span><br><span class="line">result_poly.summary()</span><br></pre></td></tr></table></figure>
<p>截距和多项式系数与 R
的结果不同。这是由于不同的实现方式造成的。剩余的系数和预测结果是等效的。</p>
<p>现在，<code>SqFtTotLiving</code>
有两个相关的系数：一个用于线性项，一个用于二次项。</p>
<p>偏残差图（参见第185页的“偏残差图与非线性”）显示，与
<code>SqFtTotLiving</code>
相关的回归方程中存在一些<strong>曲率</strong>。与线性拟合相比，拟合线（实线）更紧密地匹配偏残差的平滑曲线（虚线，参见第189页的“样条”）（见图4-10）。</p>
<p><img src="/img3/面向数据科学家的实用统计学/F4.10.png" alt="F4.10" style="zoom:50%;" /></p>
<p><code>statsmodels</code>
的实现只适用于线性项。随附的源代码提供了也适用于多项式回归的实现。</p>
<h4 id="样条回归">样条回归</h4>
<p>Splines</p>
<p><strong>多项式回归</strong>只能捕捉非线性关系中的特定曲率。添加更高阶的项，例如三次或四次多项式，常常会导致回归方程出现不必要的“弯曲”。另一种（通常更优越）的非线性关系建模方法是使用<strong>样条回归</strong>。<strong>样条</strong>提供了一种在固定点之间平滑插值的方法。样条最初被制图员用来绘制平滑曲线，尤其是在造船和飞机制造领域。</p>
<p>样条曲线是通过用被称为“<strong>鸭子</strong>”（ducks）的重物来弯曲一块薄木片而创建的；参见图4-11。</p>
<p><img src="/img3/面向数据科学家的实用统计学/F4.11.png" alt="F4.11" style="zoom:50%;" /></p>
<p>样条的正式定义是<strong>一系列分段连续的多项式</strong>。它们最早由罗马尼亚数学家
I. J. Schoenberg
在二战期间于美国阿伯丁试验场开发。这些多项式分段在预测变量中的一系列（称为结点
knots）处平滑连接。样条的公式比多项式回归复杂得多；统计软件通常会处理拟合样条的细节。R
包 <code>splines</code> 包含了 <code>bs</code>
函数，用于在回归模型中创建 b
样条（基础样条）项。例如，以下代码为房屋回归模型添加了一个 b
样条项：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>splines<span class="punctuation">)</span></span><br><span class="line">knots <span class="operator">&lt;-</span> quantile<span class="punctuation">(</span>house_98105<span class="operator">$</span>SqFtTotLiving<span class="punctuation">,</span> p<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">.25</span><span class="punctuation">,</span> <span class="number">.5</span><span class="punctuation">,</span> <span class="number">.75</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">lm_spline <span class="operator">&lt;-</span> lm<span class="punctuation">(</span>AdjSalePrice <span class="operator">~</span> bs<span class="punctuation">(</span>SqFtTotLiving<span class="punctuation">,</span> knots<span class="operator">=</span>knots<span class="punctuation">,</span> degree<span class="operator">=</span><span class="number">3</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">SqFtLot <span class="operator">+</span> Bathrooms <span class="operator">+</span> Bedrooms <span class="operator">+</span> BldgGrade<span class="punctuation">,</span> data<span class="operator">=</span>house_98105<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>需要指定两个参数：<strong>多项式的次数</strong>和<strong>结点的位置</strong>。在这个例子中，预测变量
<code>SqFtTotLiving</code>
使用<strong>三次样条</strong>（<code>degree=3</code>）被包含在模型中。默认情况下，<code>bs</code>
会在边界处设置结点；此外，结点也被设置在下四分位数、中位数和上四分位数处。</p>
<p><code>statsmodels</code> 的公式接口以类似于 R
的方式支持使用样条。在这里，我们使用 <code>df</code>（自由度）来指定 b
样条。这将创建 <code>df - degree = 6 - 3 = 3</code>
个内部结点，其位置的计算方式与上述 R 代码相同：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">formula = <span class="string">&#x27;AdjSalePrice ~ bs(SqFtTotLiving, df=6, degree=3) + &#x27;</span> +</span><br><span class="line"><span class="string">&#x27;SqFtLot + Bathrooms + Bedrooms + BldgGrade&#x27;</span></span><br><span class="line">model_spline = smf.ols(formula=formula, data=house_9105)</span><br><span class="line">result_spline = model_spline.fit()</span><br></pre></td></tr></table></figure>
<p>与线性项系数有直接意义不同，样条项的系数是<strong>不可解释的</strong>。相反，使用<strong>可视化展示</strong>来揭示样条拟合的性质更为有用。图4-12显示了回归模型的偏残差图。与多项式模型相比，样条模型更紧密地匹配平滑曲线，这展示了样条的更大灵活性。在这种情况下，拟合线更贴近数据。</p>
<p><img src="/img3/面向数据科学家的实用统计学/F4.12.png" alt="F4.12" style="zoom:50%;" /></p>
<p>这是否意味着样条回归是一个更好的模型？<strong>不一定</strong>。从经济学角度来看，面积非常小的房屋（小于1000平方英尺）的价值高于稍大一些的房屋是没有道理的。这可能是一个<strong>混杂变量</strong>造成的假象；参见第172页的“混杂变量”。</p>
<h4 id="广义加性模型">广义加性模型</h4>
<p>Generalized Additive Models</p>
<p>假设你通过先验知识或检查回归诊断，怀疑响应变量与某个预测变量之间存在非线性关系。多项式项可能不够灵活来捕捉这种关系，而样条项又需要指定结点。广义加性模型（Generalized
Additive Models, GAM）是一种灵活的建模技术，可以用于自动拟合样条回归。R
中的 <code>mgcv</code> 包可用于将 GAM 模型拟合到住房数据上：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>mgcv<span class="punctuation">)</span></span><br><span class="line">lm_gam <span class="operator">&lt;-</span> gam<span class="punctuation">(</span>AdjSalePrice <span class="operator">~</span> s<span class="punctuation">(</span>SqFtTotLiving<span class="punctuation">)</span> <span class="operator">+</span> SqFtLot <span class="operator">+</span></span><br><span class="line">Bathrooms <span class="operator">+</span> Bedrooms <span class="operator">+</span> BldgGrade<span class="punctuation">,</span></span><br><span class="line">data<span class="operator">=</span>house_98105<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><code>s(SqFtTotLiving)</code> 项告诉 <code>gam</code>
函数为样条项寻找“最佳”结点。</p>
<p>在 Python 中，我们可以使用 <code>pyGAM</code>
包。它提供了回归和分类的方法。在这里，我们使用 <code>LinearGAM</code>
来创建一个回归模型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">predictors = [<span class="string">&#x27;SqFtTotLiving&#x27;</span>, <span class="string">&#x27;SqFtLot&#x27;</span>, <span class="string">&#x27;Bathrooms&#x27;</span>, <span class="string">&#x27;Bedrooms&#x27;</span>, <span class="string">&#x27;BldgGrade&#x27;</span>]</span><br><span class="line">outcome = <span class="string">&#x27;AdjSalePrice&#x27;</span></span><br><span class="line">X = house_98105[predictors].values</span><br><span class="line">y = house_98105[outcome]</span><br><span class="line">gam = LinearGAM(s(<span class="number">0</span>, n_splines=<span class="number">12</span>) + l(<span class="number">1</span>) + l(<span class="number">2</span>) + l(<span class="number">3</span>) + l(<span class="number">4</span>))</span><br><span class="line">gam.gridsearch(X, y)</span><br></pre></td></tr></table></figure>
<p><code>n_splines</code> 的默认值是20。这对于较大的
<code>SqFtTotLiving</code>
值会导致过拟合。而12这个值可以得到一个更合理的拟合效果。</p>
<p><strong>关键思想</strong></p>
<ul>
<li><strong>离群值</strong>：回归中的离群值是具有大残差的记录。</li>
<li><strong>多重共线性</strong>：可能导致回归方程拟合时的数值不稳定。</li>
<li><strong>混杂变量</strong>：一个从模型中遗漏的重要预测变量，可能导致回归方程中出现虚假关系。</li>
<li><strong>交互项</strong>：如果一个变量的效果取决于另一个变量的水平或大小，则需要引入两个变量之间的交互项。</li>
<li><strong>多项式回归</strong>：可以拟合预测变量和结果变量之间的非线性关系。</li>
<li><strong>样条回归</strong>：是连接在结点上的一系列多项式分段。</li>
<li><strong>广义加性模型（GAM）</strong>：我们可以使用广义加性模型来自动化样条中指定结点的过程。</li>
</ul>
<h3 id="总结">总结</h3>
<p>在所有统计方法中，回归可能是多年来使用最广泛的一种方法。它旨在建立多个预测变量与一个结果变量之间的关系。其基本形式是<strong>线性</strong>的：每个预测变量都有一个系数来描述该预测变量与结果之间的线性关系。更高级的回归形式，如多项式和样条回归，允许这种关系是非线性的。在<strong>经典统计学</strong>中，重点在于找到对观察数据的一个良好拟合，以解释或描述某个现象，并且这种拟合的强度是通过传统的样本内指标来评估的。相比之下，在<strong>数据科学</strong>中，目标通常是预测新数据的值，因此使用基于样本外数据的预测准确性指标来进行模型评估。变量选择方法则用于降维和创建更紧凑的模型。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%BB%9F%E8%AE%A1/" rel="tag"># 统计</a>
              <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag"># 深度学习</a>
              <a href="/tags/AI/" rel="tag"># AI</a>
              <a href="/tags/Python/" rel="tag"># Python</a>
              <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag"># 机器学习</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/" rel="tag"># 数据科学</a>
              <a href="/tags/R/" rel="tag"># R</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/09/25/%E7%AC%AC5%E7%AB%A0%20%E5%88%86%E7%B1%BB/" rel="prev" title="第5章 分类">
                  <i class="fa fa-chevron-left"></i> 第5章 分类
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/09/25/%E7%AC%AC3%E7%AB%A0%20%E7%BB%9F%E8%AE%A1%E5%AE%9E%E9%AA%8C%E4%B8%8E%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C/" rel="next" title="第3章 统计实验与显著性检验">
                  第3章 统计实验与显著性检验 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rayman.hung</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
